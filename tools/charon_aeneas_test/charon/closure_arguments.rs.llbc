{"charon_version":"0.1.67","translated":{"crate_name":"rem_cli","real_crate_name":"rem_cli","options":{"ullbc":false,"lib":false,"bin":null,"mir_promoted":false,"mir_optimized":false,"crate_name":null,"input_file":"/home/matt/rem-matt/rem-cli/tools/charon_aeneas_test/rust/closure_arguments.rs","read_llbc":null,"dest_dir":null,"dest_file":"/home/matt/rem-matt/rem-cli/tools/charon_aeneas_test/charon/closure_arguments.rs.llbc","use_polonius":false,"no_code_duplication":false,"extract_opaque_bodies":false,"translate_all_methods":false,"include":[],"opaque":[],"exclude":[],"remove_associated_types":[],"hide_marker_traits":true,"no_cargo":false,"rustc_args":[],"cargo_args":[],"abort_on_error":false,"error_on_warnings":false,"no_serialize":false,"print_original_ullbc":false,"print_ullbc":false,"print_built_llbc":false,"print_llbc":false,"no_merge_goto_chains":false},"all_ids":[{"Fun":0},{"Fun":1},{"Type":0},{"Type":1},{"TraitDecl":0},{"Fun":2},{"Fun":3},{"Fun":4},{"TraitDecl":1},{"TraitImpl":0},{"TraitDecl":2},{"TraitDecl":3},{"TraitDecl":4},{"Fun":5},{"TraitDecl":5},{"TraitImpl":1},{"Fun":6},{"Fun":7},{"Fun":8},{"Fun":9},{"Fun":10},{"Fun":11},{"Fun":12},{"Fun":13},{"Fun":14},{"Fun":15},{"TraitDecl":6},{"Fun":16},{"Fun":17},{"TraitDecl":7},{"Fun":18},{"Fun":19},{"Fun":20},{"Fun":21},{"Type":2},{"Fun":22},{"Fun":23},{"Fun":24},{"Fun":25},{"Fun":26},{"Fun":27},{"Fun":28},{"Fun":29},{"Fun":30},{"Fun":31},{"Fun":32},{"Fun":33},{"Fun":34},{"Fun":35},{"Fun":36},{"TraitDecl":8},{"Fun":37},{"TraitDecl":9},{"TraitDecl":10},{"Fun":38},{"TraitDecl":11},{"Fun":39},{"TraitDecl":12},{"Fun":40},{"TraitDecl":13},{"Fun":41},{"Fun":42},{"Fun":43},{"Fun":44},{"Fun":45},{"Fun":46},{"Fun":47},{"Fun":48},{"Fun":49},{"Fun":50},{"Fun":51},{"Fun":52},{"Fun":53},{"TraitDecl":14},{"Fun":54},{"TraitDecl":15},{"Fun":55},{"Fun":56},{"Fun":57},{"Type":3},{"Fun":58},{"Fun":59},{"Fun":60},{"Fun":61},{"Fun":62},{"TraitDecl":16},{"Fun":63},{"Fun":64},{"Fun":65},{"Fun":66},{"TraitDecl":17},{"Fun":67},{"TraitDecl":18},{"Fun":68},{"Fun":69},{"Fun":70},{"TraitDecl":19},{"Fun":71},{"Fun":72},{"TraitDecl":20},{"Fun":73},{"Fun":74},{"Fun":75},{"Fun":76},{"Fun":77},{"Fun":78},{"Fun":79},{"Fun":80},{"Fun":81},{"Fun":82},{"TraitDecl":21},{"Fun":83},{"Fun":84},{"Fun":85},{"Fun":86},{"Fun":87},{"TraitDecl":22},{"Fun":88},{"Fun":89},{"Fun":90},{"Fun":91},{"Fun":92},{"Fun":93},{"Fun":94},{"Fun":95},{"Fun":96},{"Fun":97},{"Fun":98},{"TraitDecl":23},{"Fun":99},{"Fun":100},{"Type":4},{"Fun":101},{"Fun":102},{"Fun":103},{"Fun":104},{"Fun":105},{"Fun":106},{"Fun":107},{"Fun":108},{"Fun":109},{"Fun":110},{"Fun":111},{"Fun":112},{"Fun":113},{"Fun":114},{"Fun":115},{"Fun":116},{"Fun":117},{"Fun":118},{"TraitImpl":2},{"Fun":119},{"Fun":120},{"Fun":121},{"Fun":122},{"Fun":123},{"Fun":124},{"Fun":125},{"Fun":126},{"Fun":127},{"Fun":128},{"Fun":129},{"Fun":130},{"Fun":131},{"Fun":132},{"Fun":133},{"Fun":134},{"Fun":135},{"Fun":136}],"item_names":[{"key":{"TraitImpl":1},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["arith",0]},{"Impl":[{"Trait":1},171]}]},{"key":{"Fun":61},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["rev",0]}]},{"key":{"Fun":63},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["copied",0]}]},{"key":{"Fun":48},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["all",0]}]},{"key":{"Fun":4},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["map",0]}]},{"key":{"Fun":23},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["enumerate",0]}]},{"key":{"Fun":51},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["find_map",0]}]},{"key":{"Fun":89},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ord",0]},{"Ident":["max",0]}]},{"key":{"TraitDecl":21},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["adapters",0]},{"Ident":["zip",0]},{"Ident":["TrustedRandomAccessNoCoerce",0]}]},{"key":{"Fun":126},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["nth",0]}]},{"key":{"Fun":133},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["position",0]}]},{"key":{"Fun":93},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["partial_cmp",0]}]},{"key":{"TraitDecl":19},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]}]},{"key":{"Fun":134},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["rposition",0]}]},{"key":{"Fun":47},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["try_reduce",0]}]},{"key":{"Fun":49},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["any",0]}]},{"key":{"Fun":52},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["try_find",0]}]},{"key":{"Fun":29},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["take",0]}]},{"key":{"Fun":30},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["scan",0]}]},{"key":{"Fun":120},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["arith",0]},{"Impl":[{"Trait":2},137]},{"Ident":["mul",0]}]},{"key":{"Fun":96},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["gt",0]}]},{"key":{"Fun":12},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["last",0]}]},{"key":{"Fun":68},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["product",0]}]},{"key":{"Fun":106},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["IntoIterator",0]},{"Ident":["into_iter",0]}]},{"key":{"Fun":45},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["fold",0]}]},{"key":{"Fun":109},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["Extend",0]},{"Ident":["extend_reserve",0]}]},{"key":{"Fun":3},"value":[{"Ident":["rem_cli",0]},{"Ident":["parent",0]},{"Ident":["closure",0]}]},{"key":{"Fun":69},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["cmp",0]}]},{"key":{"Fun":58},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["max_by",0]}]},{"key":{"Fun":22},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["filter_map",0]}]},{"key":{"Fun":8},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["next",0]}]},{"key":{"TraitDecl":12},"value":[{"Ident":["core",0]},{"Ident":["default",0]},{"Ident":["Default",0]}]},{"key":{"Fun":56},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["min",0]}]},{"key":{"Type":3},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ordering",0]}]},{"key":{"TraitDecl":18},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Product",0]}]},{"key":{"Fun":102},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["adapters",0]},{"Ident":["zip",0]},{"Ident":["TrustedRandomAccessNoCoerce",0]},{"Ident":["size",0]}]},{"key":{"Fun":108},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["Extend",0]},{"Ident":["extend_one",0]}]},{"key":{"Fun":99},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Try",0]},{"Ident":["from_output",0]}]},{"key":{"Fun":124},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["last",0]}]},{"key":{"Fun":125},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["advance_by",0]}]},{"key":{"Fun":75},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["ne",0]}]},{"key":{"Fun":38},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["try_collect",0]}]},{"key":{"TraitDecl":20},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialEq",0]}]},{"key":{"Fun":15},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["step_by",0]}]},{"key":{"Fun":14},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["nth",0]}]},{"key":{"Type":0},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["adapters",0]},{"Ident":["map",0]},{"Ident":["Map",0]}]},{"key":{"Fun":59},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["min_by_key",0]}]},{"key":{"Fun":72},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["partial_cmp_by",0]}]},{"key":{"Fun":2},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Impl":[{"Ty":{"params":{"regions":[],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":[{"Builtin":"Slice"},{"regions":[],"types":[{"TypeVar":{"Bound":[0,0]}}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"kind":"InherentImplBlock"}},0]},{"Ident":["iter",0]}]},{"key":{"Fun":129},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["all",0]}]},{"key":{"Fun":130},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["any",0]}]},{"key":{"Fun":18},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["intersperse",0]}]},{"key":{"Fun":19},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["intersperse_with",0]}]},{"key":{"Type":2},"value":[{"Ident":["core",0]},{"Ident":["option",0]},{"Ident":["Option",0]}]},{"key":{"Fun":11},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["count",0]}]},{"key":{"TraitDecl":10},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Residual",0]}]},{"key":{"Fun":76},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["lt",0]}]},{"key":{"Fun":116},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]},{"Ident":["rfind",0]}]},{"key":{"Fun":121},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["next",0]}]},{"key":{"TraitDecl":7},"value":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["Clone",0]}]},{"key":{"Fun":132},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["find_map",0]}]},{"key":{"Fun":40},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["partition",0]}]},{"key":{"Fun":78},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["gt",0]}]},{"key":{"TraitDecl":23},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["FromResidual",0]}]},{"key":{"Fun":42},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["is_partitioned",0]}]},{"key":{"Fun":110},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["Extend",0]},{"Ident":["extend_one_unchecked",0]}]},{"key":{"Fun":136},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["__iterator_get_unchecked",0]}]},{"key":{"Fun":87},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialEq",0]},{"Ident":["ne",0]}]},{"key":{"Fun":5},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["arith",0]},{"Ident":["Mul",0]},{"Ident":["mul",0]}]},{"key":{"Fun":1},"value":[{"Ident":["rem_cli",0]},{"Ident":["main",0]}]},{"key":{"Fun":83},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["__iterator_get_unchecked",0]}]},{"key":{"Fun":25},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["skip_while",0]}]},{"key":{"TraitDecl":8},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["FromIterator",0]}]},{"key":{"Fun":50},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["find",0]}]},{"key":{"Fun":131},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["find",0]}]},{"key":{"Fun":32},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["flatten",0]}]},{"key":{"Fun":111},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]},{"Ident":["next_back",0]}]},{"key":{"Fun":43},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["try_fold",0]}]},{"key":{"Fun":36},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["by_ref",0]}]},{"key":{"Fun":33},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["map_windows",0]}]},{"key":{"Fun":66},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["array_chunks",0]}]},{"key":{"Fun":80},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["is_sorted",0]}]},{"key":{"Fun":55},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["max",0]}]},{"key":{"Fun":31},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["flat_map",0]}]},{"key":{"Fun":114},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]},{"Ident":["try_rfold",0]}]},{"key":{"Fun":73},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["eq",0]}]},{"key":{"Fun":88},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ord",0]},{"Ident":["cmp",0]}]},{"key":{"Fun":77},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["le",0]}]},{"key":{"Fun":65},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["cycle",0]}]},{"key":{"Fun":98},"value":[{"Ident":["core",0]},{"Ident":["default",0]},{"Ident":["Default",0]},{"Ident":["default",0]}]},{"key":{"Fun":128},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["fold",0]}]},{"key":{"Fun":85},"value":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["Clone",0]},{"Ident":["clone_from",0]}]},{"key":{"Fun":0},"value":[{"Ident":["rem_cli",0]},{"Ident":["parent",0]}]},{"key":{"Fun":20},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["for_each",0]}]},{"key":{"TraitDecl":2},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnMut",0]}]},{"key":{"Fun":28},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["skip",0]}]},{"key":{"Fun":70},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["cmp_by",0]}]},{"key":{"Fun":104},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Product",0]},{"Ident":["product",0]}]},{"key":{"Fun":7},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnOnce",0]},{"Ident":["call_once",0]}]},{"key":{"Fun":26},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["take_while",0]}]},{"key":{"Fun":54},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["rposition",0]}]},{"key":{"TraitDecl":16},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Copy",0]}]},{"key":{"Fun":79},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["ge",0]}]},{"key":{"Type":1},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Ident":["Iter",0]}]},{"key":{"Fun":91},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ord",0]},{"Ident":["clamp",0]}]},{"key":{"Fun":17},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["zip",0]}]},{"key":{"Fun":39},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["collect_into",0]}]},{"key":{"TraitDecl":3},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnOnce",0]}]},{"key":{"Fun":81},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["is_sorted_by",0]}]},{"key":{"Fun":35},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["inspect",0]}]},{"key":{"Fun":71},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["partial_cmp",0]}]},{"key":{"Fun":37},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["collect",0]}]},{"key":{"Fun":95},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["le",0]}]},{"key":{"TraitDecl":22},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Eq",0]}]},{"key":{"Fun":16},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["chain",0]}]},{"key":{"Fun":115},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]},{"Ident":["rfold",0]}]},{"key":{"Fun":122},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["size_hint",0]}]},{"key":{"Fun":101},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["FromResidual",0]},{"Ident":["from_residual",0]}]},{"key":{"TraitDecl":13},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]}]},{"key":{"Fun":113},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]},{"Ident":["nth_back",0]}]},{"key":{"TraitDecl":17},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Sum",0]}]},{"key":{"Fun":94},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["lt",0]}]},{"key":{"Fun":53},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["position",0]}]},{"key":{"Fun":92},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Eq",0]},{"Ident":["assert_receiver_is_total_eq",0]}]},{"key":{"TraitDecl":4},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Tuple",0]}]},{"key":{"Fun":118},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["exact_size",0]},{"Ident":["ExactSizeIterator",0]},{"Ident":["is_empty",0]}]},{"key":{"Fun":6},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnMut",0]},{"Ident":["call_mut",0]}]},{"key":{"Fun":27},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["map_while",0]}]},{"key":{"Fun":117},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["exact_size",0]},{"Ident":["ExactSizeIterator",0]},{"Ident":["len",0]}]},{"key":{"TraitDecl":14},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["exact_size",0]},{"Ident":["ExactSizeIterator",0]}]},{"key":{"Type":4},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["control_flow",0]},{"Ident":["ControlFlow",0]}]},{"key":{"TraitDecl":11},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["Extend",0]}]},{"key":{"Fun":107},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["Extend",0]},{"Ident":["extend",0]}]},{"key":{"TraitDecl":0},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Sized",0]}]},{"key":{"TraitDecl":6},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["IntoIterator",0]}]},{"key":{"Fun":34},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["fuse",0]}]},{"key":{"Fun":46},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["reduce",0]}]},{"key":{"Fun":64},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["cloned",0]}]},{"key":{"Fun":105},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["FromIterator",0]},{"Ident":["from_iter",0]}]},{"key":{"TraitDecl":1},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]}]},{"key":{"Fun":10},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["size_hint",0]}]},{"key":{"Fun":67},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["sum",0]}]},{"key":{"Fun":90},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ord",0]},{"Ident":["min",0]}]},{"key":{"Fun":62},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["unzip",0]}]},{"key":{"Fun":57},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["max_by_key",0]}]},{"key":{"TraitDecl":5},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["arith",0]},{"Ident":["Mul",0]}]},{"key":{"TraitImpl":2},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["arith",0]},{"Impl":[{"Trait":2},137]}]},{"key":{"Fun":103},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Sum",0]},{"Ident":["sum",0]}]},{"key":{"Fun":112},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]},{"Ident":["advance_back_by",0]}]},{"key":{"Fun":84},"value":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["Clone",0]},{"Ident":["clone",0]}]},{"key":{"Fun":135},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["is_sorted_by",0]}]},{"key":{"Fun":60},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["min_by",0]}]},{"key":{"Fun":41},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["partition_in_place",0]}]},{"key":{"Fun":9},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["next_chunk",0]}]},{"key":{"Fun":44},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["try_for_each",0]}]},{"key":{"Fun":119},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["arith",0]},{"Impl":[{"Trait":1},171]},{"Ident":["mul",0]}]},{"key":{"Fun":74},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["eq_by",0]}]},{"key":{"Fun":24},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["peekable",0]}]},{"key":{"Fun":123},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["count",0]}]},{"key":{"Fun":21},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["filter",0]}]},{"key":{"Fun":100},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Try",0]},{"Ident":["branch",0]}]},{"key":{"TraitImpl":0},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]}]},{"key":{"Fun":86},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialEq",0]},{"Ident":["eq",0]}]},{"key":{"Fun":127},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["for_each",0]}]},{"key":{"TraitDecl":9},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Try",0]}]},{"key":{"TraitDecl":15},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ord",0]}]},{"key":{"Fun":82},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["is_sorted_by_key",0]}]},{"key":{"Fun":13},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["advance_by",0]}]},{"key":{"Fun":97},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["ge",0]}]}],"files":[{"name":{"Local":"/home/matt/rem-matt/rem-cli/tools/charon_aeneas_test/rust/closure_arguments.rs"},"contents":"fn parent(factor: i32) {\n    let v = &[1, 2, 3];\n\n    v.iter().map(|it| it * factor);\n}\n\nfn main() {\n\n}\n"},{"name":{"Virtual":"/rustc/library/core/src/iter/adapters/map.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/lib.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/iter/mod.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/iter/adapters/mod.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/slice/iter.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/slice/mod.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/marker.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/iter/traits/iterator.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/iter/traits/mod.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/slice/iter/macros.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/ops/mod.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/ops/function.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/ops/arith.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/internal_macros.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/iter/traits/collect.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/clone.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/option.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/ops/try_trait.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/default.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/iter/traits/double_ended.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/iter/traits/exact_size.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/cmp.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/iter/traits/accum.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/iter/adapters/zip.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/ops/control_flow.rs"},"contents":null}],"type_decls":[{"def_id":0,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["adapters",0]},{"Ident":["map",0]},{"Ident":["Map",0]}],"span":{"span":{"file_id":1,"beg":{"line":61,"col":0},"end":{"line":61,"col":20}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" An iterator that maps the values of `iter` with `f`."},{"DocComment":""},{"DocComment":" This `struct` is created by the [`map`] method on [`Iterator`]. See its"},{"DocComment":" documentation for more."},{"DocComment":""},{"DocComment":" [`map`]: Iterator::map"},{"DocComment":" [`Iterator`]: trait.Iterator.html"},{"DocComment":""},{"DocComment":" # Notes about side effects"},{"DocComment":""},{"DocComment":" The [`map`] iterator implements [`DoubleEndedIterator`], meaning that"},{"DocComment":" you can also [`map`] backwards:"},{"DocComment":""},{"DocComment":" ```rust"},{"DocComment":" let v: Vec<i32> = [1, 2, 3].into_iter().map(|x| x + 1).rev().collect();"},{"DocComment":""},{"DocComment":" assert_eq!(v, [4, 3, 2]);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html"},{"DocComment":""},{"DocComment":" But if your closure has state, iterating backwards may act in a way you do"},{"DocComment":" not expect. Let's go through an example. First, in the forward direction:"},{"DocComment":""},{"DocComment":" ```rust"},{"DocComment":" let mut c = 0;"},{"DocComment":""},{"DocComment":" for pair in ['a', 'b', 'c'].into_iter()"},{"DocComment":"                                .map(|letter| { c += 1; (letter, c) }) {"},{"DocComment":"     println!(\"{pair:?}\");"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" This will print `('a', 1), ('b', 2), ('c', 3)`."},{"DocComment":""},{"DocComment":" Now consider this twist where we add a call to `rev`. This version will"},{"DocComment":" print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,"},{"DocComment":" but the values of the counter still go in order. This is because `map()` is"},{"DocComment":" still being called lazily on each item, but we are popping items off the"},{"DocComment":" back of the vector now, instead of shifting them from the front."},{"DocComment":""},{"DocComment":" ```rust"},{"DocComment":" let mut c = 0;"},{"DocComment":""},{"DocComment":" for pair in ['a', 'b', 'c'].into_iter()"},{"DocComment":"                                .map(|letter| { c += 1; (letter, c) })"},{"DocComment":"                                .rev() {"},{"DocComment":"     println!(\"{pair:?}\");"},{"DocComment":" }"},{"DocComment":" ```"},{"Unknown":{"path":"must_use","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"I"},{"index":1,"name":"F"}],"const_generics":[],"trait_clauses":[null,null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"kind":"Opaque"},{"def_id":1,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Ident":["Iter",0]}],"span":{"span":{"file_id":5,"beg":{"line":63,"col":0},"end":{"line":63,"col":26}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Immutable slice iterator"},{"DocComment":""},{"DocComment":" This struct is created by the [`iter`] method on [slices]."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Basic usage:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // First, we declare a type which has `iter` method to get the `Iter` struct (`&[usize]` here):"},{"DocComment":" let slice = &[1, 2, 3];"},{"DocComment":""},{"DocComment":" // Then, we iterate over it:"},{"DocComment":" for element in slice.iter() {"},{"DocComment":"     println!(\"{element}\");"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`iter`]: slice::iter"},{"DocComment":" [slices]: slice"},{"Unknown":{"path":"must_use","args":null}},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[{"index":0,"name":"'a"}],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[{"regions":[],"skip_binder":[{"TypeVar":{"Free":0}},{"Var":{"Free":0}}]},{"regions":[],"skip_binder":[{"TypeVar":{"Free":0}},{"Var":{"Free":0}}]}],"trait_type_constraints":[]},"kind":"Opaque"},{"def_id":2,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["option",0]},{"Ident":["Option",0]}],"span":{"span":{"file_id":17,"beg":{"line":571,"col":0},"end":{"line":571,"col":18}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" The `Option` type. See [the module level documentation](self) for more."},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"kind":{"Enum":[{"span":{"span":{"file_id":17,"beg":{"line":575,"col":4},"end":{"line":575,"col":8}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" No value."}],"inline":null,"rename":null,"public":true},"name":"None","fields":[],"discriminant":{"Isize":"0"}},{"span":{"span":{"file_id":17,"beg":{"line":579,"col":4},"end":{"line":579,"col":8}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" Some value of type `T`."}],"inline":null,"rename":null,"public":true},"name":"Some","fields":[{"span":{"span":{"file_id":17,"beg":{"line":579,"col":55},"end":{"line":579,"col":56}},"generated_from_span":null},"attr_info":{"attributes":[],"inline":null,"rename":null,"public":true},"name":null,"ty":{"TypeVar":{"Free":0}}}],"discriminant":{"Isize":"1"}}]}},{"def_id":3,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ordering",0]}],"span":{"span":{"file_id":22,"beg":{"line":387,"col":0},"end":{"line":387,"col":17}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" An `Ordering` is the result of a comparison between two values."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" assert_eq!(1.cmp(&2), Ordering::Less);"},{"DocComment":""},{"DocComment":" assert_eq!(1.cmp(&1), Ordering::Equal);"},{"DocComment":""},{"DocComment":" assert_eq!(2.cmp(&1), Ordering::Greater);"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"kind":{"Enum":[{"span":{"span":{"file_id":22,"beg":{"line":390,"col":4},"end":{"line":390,"col":8}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" An ordering where a compared value is less than another."}],"inline":null,"rename":null,"public":true},"name":"Less","fields":[],"discriminant":{"I8":"-1"}},{"span":{"span":{"file_id":22,"beg":{"line":393,"col":4},"end":{"line":393,"col":9}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" An ordering where a compared value is equal to another."}],"inline":null,"rename":null,"public":true},"name":"Equal","fields":[],"discriminant":{"I8":"0"}},{"span":{"span":{"file_id":22,"beg":{"line":396,"col":4},"end":{"line":396,"col":11}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" An ordering where a compared value is greater than another."}],"inline":null,"rename":null,"public":true},"name":"Greater","fields":[],"discriminant":{"I8":"1"}}]}},{"def_id":4,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["control_flow",0]},{"Ident":["ControlFlow",0]}],"span":{"span":{"file_id":25,"beg":{"line":85,"col":0},"end":{"line":85,"col":31}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Used to tell an operation whether it should exit early or go on as usual."},{"DocComment":""},{"DocComment":" This is used when exposing things (like graph traversals or visitors) where"},{"DocComment":" you want the user to be able to choose whether to exit early."},{"DocComment":" Having the enum makes it clearer -- no more wondering \"wait, what did `false`"},{"DocComment":" mean again?\" -- and allows including a value."},{"DocComment":""},{"DocComment":" Similar to [`Option`] and [`Result`], this enum can be used with the `?` operator"},{"DocComment":" to return immediately if the [`Break`] variant is present or otherwise continue normally"},{"DocComment":" with the value inside the [`Continue`] variant."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Early-exiting from [`Iterator::try_for_each`]:"},{"DocComment":" ```"},{"DocComment":" use std::ops::ControlFlow;"},{"DocComment":""},{"DocComment":" let r = (2..100).try_for_each(|x| {"},{"DocComment":"     if 403 % x == 0 {"},{"DocComment":"         return ControlFlow::Break(x)"},{"DocComment":"     }"},{"DocComment":""},{"DocComment":"     ControlFlow::Continue(())"},{"DocComment":" });"},{"DocComment":" assert_eq!(r, ControlFlow::Break(13));"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" A basic tree traversal:"},{"DocComment":" ```"},{"DocComment":" use std::ops::ControlFlow;"},{"DocComment":""},{"DocComment":" pub struct TreeNode<T> {"},{"DocComment":"     value: T,"},{"DocComment":"     left: Option<Box<TreeNode<T>>>,"},{"DocComment":"     right: Option<Box<TreeNode<T>>>,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl<T> TreeNode<T> {"},{"DocComment":"     pub fn traverse_inorder<B>(&self, f: &mut impl FnMut(&T) -> ControlFlow<B>) -> ControlFlow<B> {"},{"DocComment":"         if let Some(left) = &self.left {"},{"DocComment":"             left.traverse_inorder(f)?;"},{"DocComment":"         }"},{"DocComment":"         f(&self.value)?;"},{"DocComment":"         if let Some(right) = &self.right {"},{"DocComment":"             right.traverse_inorder(f)?;"},{"DocComment":"         }"},{"DocComment":"         ControlFlow::Continue(())"},{"DocComment":"     }"},{"DocComment":"     fn leaf(value: T) -> Option<Box<TreeNode<T>>> {"},{"DocComment":"         Some(Box::new(Self { value, left: None, right: None }))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let node = TreeNode {"},{"DocComment":"     value: 0,"},{"DocComment":"     left: TreeNode::leaf(1),"},{"DocComment":"     right: Some(Box::new(TreeNode {"},{"DocComment":"         value: -1,"},{"DocComment":"         left: TreeNode::leaf(5),"},{"DocComment":"         right: TreeNode::leaf(2),"},{"DocComment":"     }))"},{"DocComment":" };"},{"DocComment":" let mut sum = 0;"},{"DocComment":""},{"DocComment":" let res = node.traverse_inorder(&mut |val| {"},{"DocComment":"     if *val < 0 {"},{"DocComment":"         ControlFlow::Break(*val)"},{"DocComment":"     } else {"},{"DocComment":"         sum += *val;"},{"DocComment":"         ControlFlow::Continue(())"},{"DocComment":"     }"},{"DocComment":" });"},{"DocComment":" assert_eq!(res, ControlFlow::Break(-1));"},{"DocComment":" assert_eq!(sum, 6);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`Break`]: ControlFlow::Break"},{"DocComment":" [`Continue`]: ControlFlow::Continue"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"B"},{"index":1,"name":"C"}],"const_generics":[],"trait_clauses":[null,null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"kind":{"Enum":[{"span":{"span":{"file_id":25,"beg":{"line":89,"col":4},"end":{"line":89,"col":12}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" Move on to the next phase of the operation as normal."}],"inline":null,"rename":null,"public":true},"name":"Continue","fields":[{"span":{"span":{"file_id":25,"beg":{"line":89,"col":13},"end":{"line":89,"col":14}},"generated_from_span":null},"attr_info":{"attributes":[],"inline":null,"rename":null,"public":true},"name":null,"ty":{"TypeVar":{"Free":1}}}],"discriminant":{"Isize":"0"}},{"span":{"span":{"file_id":25,"beg":{"line":93,"col":4},"end":{"line":93,"col":9}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" Exit the operation without running subsequent phases."}],"inline":null,"rename":null,"public":true},"name":"Break","fields":[{"span":{"span":{"file_id":25,"beg":{"line":93,"col":10},"end":{"line":93,"col":11}},"generated_from_span":null},"attr_info":{"attributes":[],"inline":null,"rename":null,"public":true},"name":null,"ty":{"TypeVar":{"Free":0}}}],"discriminant":{"Isize":"1"}}]}}],"fun_decls":[{"def_id":0,"item_meta":{"name":[{"Ident":["rem_cli",0]},{"Ident":["parent",0]}],"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":5,"col":1}},"generated_from_span":null},"source_text":"fn parent(factor: i32) {\n    let v = &[1, 2, 3];\n\n    v.iter().map(|it| it * factor);\n}","attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":true,"opacity":"Transparent"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Literal":{"Integer":"I32"}}],"output":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},"kind":"Regular","is_global_initializer":null,"body":{"Ok":{"Structured":{"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":5,"col":1}},"generated_from_span":null},"locals":{"arg_count":1,"vars":[{"index":0,"name":null,"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"index":1,"name":"factor","ty":{"Literal":{"Integer":"I32"}}},{"index":2,"name":"v","ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[{"Value":{"Scalar":{"Usize":"3"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},{"index":3,"name":null,"ty":{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[{"Value":{"Scalar":{"Usize":"3"}}}],"trait_refs":[],"target":"Builtin"}]}},{"index":4,"name":null,"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[{"Adt":[{"Adt":1},{"regions":["Erased"],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":1}}}]},{"Arrow":{"regions":[],"skip_binder":[[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],{"Literal":{"Integer":"I32"}}]}}],"const_generics":[],"trait_refs":[null,null],"target":{"Item":{"Type":0}}}]}},{"index":5,"name":null,"ty":{"Adt":[{"Adt":1},{"regions":["Erased"],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":1}}}]}},{"index":6,"name":null,"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Slice"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},{"index":7,"name":null,"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[{"Value":{"Scalar":{"Usize":"3"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},{"index":8,"name":null,"ty":{"Arrow":{"regions":[],"skip_binder":[[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],{"Literal":{"Integer":"I32"}}]}}},{"index":9,"name":null,"ty":{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}},{"index":10,"name":null,"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}}]},"comments":[],"body":{"span":{"span":{"file_id":0,"beg":{"line":1,"col":23},"end":{"line":5,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":2,"col":13},"end":{"line":2,"col":22}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":3},"ty":{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[{"Value":{"Scalar":{"Usize":"3"}}}],"trait_refs":[],"target":"Builtin"}]}},{"Aggregate":[{"Array":[{"Literal":{"Integer":"I32"}},{"Value":{"Scalar":{"Usize":"3"}}}]},[{"Const":{"value":{"Literal":{"Scalar":{"I32":"1"}}},"ty":{"Literal":{"Integer":"I32"}}}},{"Const":{"value":{"Literal":{"Scalar":{"I32":"2"}}},"ty":{"Literal":{"Integer":"I32"}}}},{"Const":{"value":{"Literal":{"Scalar":{"I32":"3"}}},"ty":{"Literal":{"Integer":"I32"}}}}]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":2,"col":12},"end":{"line":2,"col":22}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":2},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[{"Value":{"Scalar":{"Usize":"3"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},{"Ref":[{"kind":{"Base":3},"ty":{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[{"Value":{"Scalar":{"Usize":"3"}}}],"trait_refs":[],"target":"Builtin"}]}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":2,"col":8},"end":{"line":2,"col":9}},"generated_from_span":null},"content":{"FakeRead":{"kind":{"Base":2},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[{"Value":{"Scalar":{"Usize":"3"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":4},"end":{"line":4,"col":5}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":7},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[{"Value":{"Scalar":{"Usize":"3"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},{"Ref":[{"kind":{"Projection":[{"kind":{"Base":2},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[{"Value":{"Scalar":{"Usize":"3"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}},"Deref"]},"ty":{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[{"Value":{"Scalar":{"Usize":"3"}}}],"trait_refs":[],"target":"Builtin"}]}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":4},"end":{"line":4,"col":5}},"generated_from_span":null},"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Builtin":"ArrayToSliceShared"}},"generics":{"regions":["Erased"],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[{"Value":{"Scalar":{"Usize":"3"}}}],"trait_refs":[],"target":"Builtin"}}},"args":[{"Move":{"kind":{"Base":7},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[{"Value":{"Scalar":{"Usize":"3"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}}],"dest":{"kind":{"Base":6},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Slice"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":4},"end":{"line":4,"col":5}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":7},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[{"Value":{"Scalar":{"Usize":"3"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":4},"end":{"line":4,"col":12}},"generated_from_span":null},"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":2}},"generics":{"regions":["Erased"],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Fun":2}}}}},"args":[{"Move":{"kind":{"Base":6},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Slice"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}}],"dest":{"kind":{"Base":5},"ty":{"Adt":[{"Adt":1},{"regions":["Erased"],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":1}}}]}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":11},"end":{"line":4,"col":12}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":6},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Slice"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":17},"end":{"line":4,"col":33}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":9},"ty":{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}},{"Ref":[{"kind":{"Base":1},"ty":{"Literal":{"Integer":"I32"}}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":17},"end":{"line":4,"col":33}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":8},"ty":{"Arrow":{"regions":[],"skip_binder":[[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],{"Literal":{"Integer":"I32"}}]}}},{"Aggregate":[{"Closure":[3,{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":3}}}]},[{"Move":{"kind":{"Base":9},"ty":{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}}}]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":20},"end":{"line":4,"col":21}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":9},"ty":{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":4},"end":{"line":4,"col":34}},"generated_from_span":null},"content":{"Call":{"func":{"Regular":{"func":{"Trait":[{"kind":{"TraitImpl":[0,{"regions":["Erased"],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"TraitImpl":0}}}]},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"Adt":[{"Adt":1},{"regions":["Erased"],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":1}}}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},"map",4]},"generics":{"regions":[],"types":[{"Literal":{"Integer":"I32"}},{"Arrow":{"regions":[],"skip_binder":[[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],{"Literal":{"Integer":"I32"}}]}}],"const_generics":[],"trait_refs":[null,null,null,{"kind":{"BuiltinOrAuto":{"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":2,"generics":{"regions":[],"types":[{"Arrow":{"regions":[],"skip_binder":[[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],{"Literal":{"Integer":"I32"}}]}},{"Adt":["Tuple",{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}}},"parent_trait_refs":[{"kind":{"BuiltinOrAuto":{"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":3,"generics":{"regions":[],"types":[{"Arrow":{"regions":[],"skip_binder":[[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],{"Literal":{"Integer":"I32"}}]}},{"Adt":["Tuple",{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":3}}}}},"parent_trait_refs":[{"kind":{"BuiltinOrAuto":{"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":0,"generics":{"regions":[],"types":[{"Adt":["Tuple",{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":0}}}}},"parent_trait_refs":[],"types":[]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":0,"generics":{"regions":[],"types":[{"Adt":["Tuple",{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":0}}}}}},{"kind":{"BuiltinOrAuto":{"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":4,"generics":{"regions":[],"types":[{"Adt":["Tuple",{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":4}}}}},"parent_trait_refs":[],"types":[]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":4,"generics":{"regions":[],"types":[{"Adt":["Tuple",{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":4}}}}}}],"types":[["Output",{"Literal":{"Integer":"I32"}}]]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":3,"generics":{"regions":[],"types":[{"Arrow":{"regions":[],"skip_binder":[[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],{"Literal":{"Integer":"I32"}}]}},{"Adt":["Tuple",{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":3}}}}}},{"kind":{"BuiltinOrAuto":{"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":0,"generics":{"regions":[],"types":[{"Adt":["Tuple",{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":0}}}}},"parent_trait_refs":[],"types":[]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":0,"generics":{"regions":[],"types":[{"Adt":["Tuple",{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":0}}}}}},{"kind":{"BuiltinOrAuto":{"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":4,"generics":{"regions":[],"types":[{"Adt":["Tuple",{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":4}}}}},"parent_trait_refs":[],"types":[]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":4,"generics":{"regions":[],"types":[{"Adt":["Tuple",{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":4}}}}}}],"types":[]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":2,"generics":{"regions":[],"types":[{"Arrow":{"regions":[],"skip_binder":[[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],{"Literal":{"Integer":"I32"}}]}},{"Adt":["Tuple",{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}}}}],"target":{"Method":[1,"map"]}}}},"args":[{"Move":{"kind":{"Base":5},"ty":{"Adt":[{"Adt":1},{"regions":["Erased"],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":1}}}]}}},{"Move":{"kind":{"Base":8},"ty":{"Arrow":{"regions":[],"skip_binder":[[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],{"Literal":{"Integer":"I32"}}]}}}}],"dest":{"kind":{"Base":4},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[{"Adt":[{"Adt":1},{"regions":["Erased"],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":1}}}]},{"Arrow":{"regions":[],"skip_binder":[[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],{"Literal":{"Integer":"I32"}}]}}],"const_generics":[],"trait_refs":[null,null],"target":{"Item":{"Type":0}}}]}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":33},"end":{"line":4,"col":34}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":8},"ty":{"Arrow":{"regions":[],"skip_binder":[[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],{"Literal":{"Integer":"I32"}}]}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":33},"end":{"line":4,"col":34}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":5},"ty":{"Adt":[{"Adt":1},{"regions":["Erased"],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":1}}}]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":34},"end":{"line":4,"col":35}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":4},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[{"Adt":[{"Adt":1},{"regions":["Erased"],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":1}}}]},{"Arrow":{"regions":[],"skip_binder":[[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],{"Literal":{"Integer":"I32"}}]}}],"const_generics":[],"trait_refs":[null,null],"target":{"Item":{"Type":0}}}]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":1,"col":23},"end":{"line":5,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":10},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"Aggregate":[{"Adt":["Tuple",null,null,{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},[]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":1,"col":23},"end":{"line":5,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":0},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"Use":{"Move":{"kind":{"Base":10},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":0},"end":{"line":5,"col":1}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":3},"ty":{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[{"Value":{"Scalar":{"Usize":"3"}}}],"trait_refs":[],"target":"Builtin"}]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":0},"end":{"line":5,"col":1}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":2},"ty":{"Ref":["Erased",{"Adt":[{"Builtin":"Array"},{"regions":[],"types":[{"Literal":{"Integer":"I32"}}],"const_generics":[{"Value":{"Scalar":{"Usize":"3"}}}],"trait_refs":[],"target":"Builtin"}]},"Shared"]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":1},"end":{"line":5,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":0},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"Aggregate":[{"Adt":["Tuple",null,null,{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},[]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":1},"end":{"line":5,"col":1}},"generated_from_span":null},"content":"Return","comments_before":[]}]}}}}},{"def_id":1,"item_meta":{"name":[{"Ident":["rem_cli",0]},{"Ident":["main",0]}],"span":{"span":{"file_id":0,"beg":{"line":7,"col":0},"end":{"line":9,"col":1}},"generated_from_span":null},"source_text":"fn main() {\n\n}","attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":true,"opacity":"Transparent"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[],"output":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},"kind":"Regular","is_global_initializer":null,"body":{"Ok":{"Structured":{"span":{"span":{"file_id":0,"beg":{"line":7,"col":0},"end":{"line":9,"col":1}},"generated_from_span":null},"locals":{"arg_count":0,"vars":[{"index":0,"name":null,"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"index":1,"name":null,"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}}]},"comments":[],"body":{"span":{"span":{"file_id":0,"beg":{"line":7,"col":10},"end":{"line":9,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":7,"col":10},"end":{"line":9,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":1},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"Aggregate":[{"Adt":["Tuple",null,null,{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},[]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":7,"col":10},"end":{"line":9,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":0},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"Use":{"Move":{"kind":{"Base":1},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":9,"col":1},"end":{"line":9,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":0},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"Aggregate":[{"Adt":["Tuple",null,null,{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},[]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":9,"col":1},"end":{"line":9,"col":1}},"generated_from_span":null},"content":"Return","comments_before":[]}]}}}}},{"def_id":2,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Impl":[{"Ty":{"params":{"regions":[],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":[{"Builtin":"Slice"},{"regions":[],"types":[{"TypeVar":{"Bound":[0,0]}}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"kind":"InherentImplBlock"}},0]},{"Ident":["iter",0]}],"span":{"span":{"file_id":6,"beg":{"line":1012,"col":4},"end":{"line":1012,"col":37}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Returns an iterator over the slice."},{"DocComment":""},{"DocComment":" The iterator yields all items from start to end."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let x = &[1, 2, 4];"},{"DocComment":" let mut iterator = x.iter();"},{"DocComment":""},{"DocComment":" assert_eq!(iterator.next(), Some(&1));"},{"DocComment":" assert_eq!(iterator.next(), Some(&2));"},{"DocComment":" assert_eq!(iterator.next(), Some(&4));"},{"DocComment":" assert_eq!(iterator.next(), None);"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":[{"Builtin":"Slice"},{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Shared"]}],"output":{"Adt":[{"Adt":1},{"regions":[{"Var":{"Free":0}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":1}}}]}},"kind":"Regular","is_global_initializer":null,"body":{"Err":null}},{"def_id":3,"item_meta":{"name":[{"Ident":["rem_cli",0]},{"Ident":["parent",0]},{"Ident":["closure",0]}],"span":{"span":{"file_id":0,"beg":{"line":4,"col":17},"end":{"line":4,"col":33}},"generated_from_span":null},"source_text":"|it| it * factor","attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":true,"opacity":"Transparent"},"signature":{"is_unsafe":false,"is_closure":true,"closure_info":{"kind":"FnMut","state":[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}]},"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":["Tuple",{"regions":[],"types":[{"Ref":[{"Var":{"Free":1}},{"Literal":{"Integer":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Mut"]},{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],"output":{"Literal":{"Integer":"I32"}}},"kind":"Regular","is_global_initializer":null,"body":{"Ok":{"Structured":{"span":{"span":{"file_id":0,"beg":{"line":4,"col":17},"end":{"line":4,"col":33}},"generated_from_span":null},"locals":{"arg_count":2,"vars":[{"index":0,"name":null,"ty":{"Literal":{"Integer":"I32"}}},{"index":1,"name":"state","ty":{"Ref":[{"Var":{"Free":0}},{"Adt":["Tuple",{"regions":[],"types":[{"Ref":[{"Var":{"Free":1}},{"Literal":{"Integer":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},"Mut"]}},{"index":2,"name":"it","ty":{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}},{"index":3,"name":null,"ty":{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}},{"index":4,"name":null,"ty":{"Literal":{"Integer":"I32"}}}]},"comments":[],"body":{"span":{"span":{"file_id":0,"beg":{"line":4,"col":22},"end":{"line":4,"col":33}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":4,"col":22},"end":{"line":4,"col":24}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":3},"ty":{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}},{"Use":{"Copy":{"kind":{"Base":2},"ty":{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":27},"end":{"line":4,"col":33}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":4},"ty":{"Literal":{"Integer":"I32"}}},{"Use":{"Copy":{"kind":{"Projection":[{"kind":{"Projection":[{"kind":{"Projection":[{"kind":{"Base":1},"ty":{"Ref":["Erased",{"Arrow":{"regions":[],"skip_binder":[[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],{"Literal":{"Integer":"I32"}}]}},"Mut"]}},"Deref"]},"ty":{"Arrow":{"regions":[],"skip_binder":[[{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}],{"Literal":{"Integer":"I32"}}]}}},{"Field":[{"Tuple":1},0]}]},"ty":{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}},"Deref"]},"ty":{"Literal":{"Integer":"I32"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":22},"end":{"line":4,"col":33}},"generated_from_span":null},"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":119}},"generics":{"regions":["Erased"],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":119}}}}},"args":[{"Move":{"kind":{"Base":3},"ty":{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}}},{"Move":{"kind":{"Base":4},"ty":{"Literal":{"Integer":"I32"}}}}],"dest":{"kind":{"Base":0},"ty":{"Literal":{"Integer":"I32"}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":32},"end":{"line":4,"col":33}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":4},"ty":{"Literal":{"Integer":"I32"}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":32},"end":{"line":4,"col":33}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":3},"ty":{"Ref":["Erased",{"Literal":{"Integer":"I32"}},"Shared"]}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":33},"end":{"line":4,"col":33}},"generated_from_span":null},"content":"Return","comments_before":[]}]}}}}},{"def_id":4,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["map",0]}],"span":{"span":{"file_id":8,"beg":{"line":757,"col":4},"end":{"line":760,"col":34}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Takes a closure and creates an iterator which calls that closure on each"},{"DocComment":" element."},{"DocComment":""},{"DocComment":" `map()` transforms one iterator into another, by means of its argument:"},{"DocComment":" something that implements [`FnMut`]. It produces a new iterator which"},{"DocComment":" calls this closure on each element of the original iterator."},{"DocComment":""},{"DocComment":" If you are good at thinking in types, you can think of `map()` like this:"},{"DocComment":" If you have an iterator that gives you elements of some type `A`, and"},{"DocComment":" you want an iterator of some other type `B`, you can use `map()`,"},{"DocComment":" passing a closure that takes an `A` and returns a `B`."},{"DocComment":""},{"DocComment":" `map()` is conceptually similar to a [`for`] loop. However, as `map()` is"},{"DocComment":" lazy, it is best used when you're already working with other iterators."},{"DocComment":" If you're doing some sort of looping for a side effect, it's considered"},{"DocComment":" more idiomatic to use [`for`] than `map()`."},{"DocComment":""},{"DocComment":" [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Basic usage:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let a = [1, 2, 3];"},{"DocComment":""},{"DocComment":" let mut iter = a.iter().map(|x| 2 * x);"},{"DocComment":""},{"DocComment":" assert_eq!(iter.next(), Some(2));"},{"DocComment":" assert_eq!(iter.next(), Some(4));"},{"DocComment":" assert_eq!(iter.next(), Some(6));"},{"DocComment":" assert_eq!(iter.next(), None);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" If you're doing some sort of side effect, prefer [`for`] to `map()`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #![allow(unused_must_use)]"},{"DocComment":" // don't do this:"},{"DocComment":" (0..5).map(|x| println!(\"{x}\"));"},{"DocComment":""},{"DocComment":" // it won't even execute, as it is lazy. Rust will warn you about this."},{"DocComment":""},{"DocComment":" // Instead, use for:"},{"DocComment":" for x in 0..5 {"},{"DocComment":"     println!(\"{x}\");"},{"DocComment":" }"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_diagnostic_item","args":null}},{"Unknown":{"path":"rustc_do_not_const_check","args":null}}],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"B"},{"index":2,"name":"F"}],"const_generics":[],"trait_clauses":[null,null,null,{"clause_id":3,"span":{"span":{"file_id":8,"beg":{"line":760,"col":11},"end":{"line":760,"col":33}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}},{"Adt":["Tuple",{"regions":[],"types":[{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},"Item"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[{"regions":[],"skip_binder":{"trait_ref":{"kind":{"ParentClause":[{"Clause":{"Free":3}},2,0]},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":3,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}},{"Adt":["Tuple",{"regions":[],"types":[{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},"Item"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":3}}}}}},"type_name":"Output","ty":{"TypeVar":{"Free":1}}}}]},"inputs":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":2}}],"output":{"Adt":[{"Adt":0},{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[null,null],"target":{"Item":{"Type":0}}}]}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}},"item_name":"map","has_default":true}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":5,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["arith",0]},{"Ident":["Mul",0]},{"Ident":["mul",0]}],"span":{"span":{"file_id":13,"beg":{"line":330,"col":4},"end":{"line":330,"col":43}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Performs the `*` operation."},{"DocComment":""},{"DocComment":" # Example"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" assert_eq!(12 * 2, 24);"},{"DocComment":" ```"},{"Unknown":{"path":"must_use","args":null}},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Rhs"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"output":{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":5,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":5}}}}}},"Output"]}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":5,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":5}}}},"item_name":"mul","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":6,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnMut",0]},{"Ident":["call_mut",0]}],"span":{"span":{"file_id":12,"beg":{"line":166,"col":4},"end":{"line":166,"col":74}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Performs the call operation."},{"Unknown":{"path":"unstable","args":"feature = \"fn_traits\", issue = \"29625\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Args"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Mut"]},{"TypeVar":{"Free":1}}],"output":{"TraitType":[{"kind":{"ParentClause":["SelfId",2,0]},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":3,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":3}}}}}},"Output"]}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}},"item_name":"call_mut","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":7,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnOnce",0]},{"Ident":["call_once",0]}],"span":{"span":{"file_id":12,"beg":{"line":250,"col":4},"end":{"line":250,"col":70}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Performs the call operation."},{"Unknown":{"path":"unstable","args":"feature = \"fn_traits\", issue = \"29625\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Args"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"output":{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":3,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":3}}}}}},"Output"]}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":3,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":3}}}},"item_name":"call_once","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":8,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["next",0]}],"span":{"span":{"file_id":8,"beg":{"line":75,"col":4},"end":{"line":75,"col":45}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Advances the iterator and returns the next value."},{"DocComment":""},{"DocComment":" Returns [`None`] when iteration is finished. Individual iterator"},{"DocComment":" implementations may choose to resume iteration, and so calling `next()`"},{"DocComment":" again may or may not eventually start returning [`Some(Item)`] again at some"},{"DocComment":" point."},{"DocComment":""},{"DocComment":" [`Some(Item)`]: Some"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let a = [1, 2, 3];"},{"DocComment":""},{"DocComment":" let mut iter = a.iter();"},{"DocComment":""},{"DocComment":" // A call to next() returns the next value..."},{"DocComment":" assert_eq!(Some(&1), iter.next());"},{"DocComment":" assert_eq!(Some(&2), iter.next());"},{"DocComment":" assert_eq!(Some(&3), iter.next());"},{"DocComment":""},{"DocComment":" // ... and then None once it's over."},{"DocComment":" assert_eq!(None, iter.next());"},{"DocComment":""},{"DocComment":" // More calls may or may not return `None`. Here, they always will."},{"DocComment":" assert_eq!(None, iter.next());"},{"DocComment":" assert_eq!(None, iter.next());"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Mut"]}],"output":{"Adt":[{"Adt":2},{"regions":[],"types":[{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},"Item"]}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":2}}}]}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}},"item_name":"next","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"def_id":84,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["Clone",0]},{"Ident":["clone",0]}],"span":{"span":{"file_id":16,"beg":{"line":165,"col":4},"end":{"line":165,"col":28}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Returns a copy of the value."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #![allow(noop_method_call)]"},{"DocComment":" let hello = \"Hello\"; // &str implements Clone"},{"DocComment":""},{"DocComment":" assert_eq!(\"Hello\", hello.clone());"},{"DocComment":" ```"},{"Unknown":{"path":"must_use","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]}],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":7,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":7}}}},"item_name":"clone","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,{"def_id":86,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialEq",0]},{"Ident":["eq",0]}],"span":{"span":{"file_id":22,"beg":{"line":253,"col":4},"end":{"line":253,"col":38}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Tests for `self` and `other` values to be equal, and is used by `==`."},{"Unknown":{"path":"must_use","args":null}},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Rhs"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"TypeVar":{"Free":1}},"Shared"]}],"output":{"Literal":"Bool"}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":20,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":20}}}},"item_name":"eq","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,{"def_id":88,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ord",0]},{"Ident":["cmp",0]}],"span":{"span":{"file_id":22,"beg":{"line":964,"col":4},"end":{"line":964,"col":44}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" This method returns an [`Ordering`] between `self` and `other`."},{"DocComment":""},{"DocComment":" By convention, `self.cmp(&other)` returns the ordering matching the expression"},{"DocComment":" `self <operator> other` if true."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" assert_eq!(5.cmp(&10), Ordering::Less);"},{"DocComment":" assert_eq!(10.cmp(&5), Ordering::Greater);"},{"DocComment":" assert_eq!(5.cmp(&5), Ordering::Equal);"},{"DocComment":" ```"},{"Unknown":{"path":"must_use","args":null}},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"TypeVar":{"Free":0}},"Shared"]}],"output":{"Adt":[{"Adt":3},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":3}}}]}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":15,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":15}}}},"item_name":"cmp","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,null,{"def_id":93,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["partial_cmp",0]}],"span":{"span":{"file_id":22,"beg":{"line":1320,"col":4},"end":{"line":1320,"col":59}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" This method returns an ordering between `self` and `other` values if one exists."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" let result = 1.0.partial_cmp(&2.0);"},{"DocComment":" assert_eq!(result, Some(Ordering::Less));"},{"DocComment":""},{"DocComment":" let result = 1.0.partial_cmp(&1.0);"},{"DocComment":" assert_eq!(result, Some(Ordering::Equal));"},{"DocComment":""},{"DocComment":" let result = 2.0.partial_cmp(&1.0);"},{"DocComment":" assert_eq!(result, Some(Ordering::Greater));"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" When comparison is impossible:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let result = f64::NAN.partial_cmp(&1.0);"},{"DocComment":" assert_eq!(result, None);"},{"DocComment":" ```"},{"Unknown":{"path":"must_use","args":null}},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Rhs"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"TypeVar":{"Free":1}},"Shared"]}],"output":{"Adt":[{"Adt":2},{"regions":[],"types":[{"Adt":[{"Adt":3},{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Type":3}}}]}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":2}}}]}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":19,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":19}}}},"item_name":"partial_cmp","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,null,{"def_id":98,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["default",0]},{"Ident":["Default",0]},{"Ident":["default",0]}],"span":{"span":{"file_id":19,"beg":{"line":139,"col":4},"end":{"line":139,"col":25}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Returns the \"default value\" for a type."},{"DocComment":""},{"DocComment":" Default values are often some kind of initial value, identity value, or anything else that"},{"DocComment":" may make sense as a default."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Using built-in default values:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let i: i8 = Default::default();"},{"DocComment":" let (x, y): (Option<String>, f64) = Default::default();"},{"DocComment":" let (a, b, (c, d)): (i32, u32, (bool, bool)) = Default::default();"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Making your own:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #[allow(dead_code)]"},{"DocComment":" enum Kind {"},{"DocComment":"     A,"},{"DocComment":"     B,"},{"DocComment":"     C,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Default for Kind {"},{"DocComment":"     fn default() -> Self { Kind::A }"},{"DocComment":" }"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":12,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":12}}}},"item_name":"default","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":99,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Try",0]},{"Ident":["from_output",0]}],"span":{"span":{"file_id":18,"beg":{"line":190,"col":4},"end":{"line":190,"col":49}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Constructs the type from its `Output` type."},{"DocComment":""},{"DocComment":" This should be implemented consistently with the `branch` method"},{"DocComment":" such that applying the `?` operator will get back the original value:"},{"DocComment":" `Try::from_output(x).branch() --> ControlFlow::Continue(x)`."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #![feature(try_trait_v2)]"},{"DocComment":" use std::ops::Try;"},{"DocComment":""},{"DocComment":" assert_eq!(<Result<_, String> as Try>::from_output(3), Ok(3));"},{"DocComment":" assert_eq!(<Option<_> as Try>::from_output(4), Some(4));"},{"DocComment":" assert_eq!("},{"DocComment":"     <std::ops::ControlFlow<String, _> as Try>::from_output(5),"},{"DocComment":"     std::ops::ControlFlow::Continue(5),"},{"DocComment":" );"},{"DocComment":""},{"DocComment":" # fn make_question_mark_work() -> Option<()> {"},{"DocComment":" assert_eq!(Option::from_output(4)?, 4);"},{"DocComment":" # None }"},{"DocComment":" # make_question_mark_work();"},{"DocComment":""},{"DocComment":" // This is used, for example, on the accumulator in `try_fold`:"},{"DocComment":" let r = std::iter::empty().try_fold(4, |_, ()| -> Option<_> { unreachable!() });"},{"DocComment":" assert_eq!(r, Some(4));"},{"DocComment":" ```"},{"Unknown":{"path":"unstable","args":"feature = \"try_trait_v2\", issue = \"84277\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":9}}}}}},"Output"]}],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":9}}}},"item_name":"from_output","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":100,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Try",0]},{"Ident":["branch",0]}],"span":{"span":{"file_id":18,"beg":{"line":217,"col":4},"end":{"line":217,"col":65}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Used in `?` to decide whether the operator should produce a value"},{"DocComment":" (because this returned [`ControlFlow::Continue`])"},{"DocComment":" or propagate a value back to the caller"},{"DocComment":" (because this returned [`ControlFlow::Break`])."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #![feature(try_trait_v2)]"},{"DocComment":" use std::ops::{ControlFlow, Try};"},{"DocComment":""},{"DocComment":" assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));"},{"DocComment":" assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));"},{"DocComment":""},{"DocComment":" assert_eq!(Some(3).branch(), ControlFlow::Continue(3));"},{"DocComment":" assert_eq!(None::<String>.branch(), ControlFlow::Break(None));"},{"DocComment":""},{"DocComment":" assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));"},{"DocComment":" assert_eq!("},{"DocComment":"     ControlFlow::<_, String>::Break(3).branch(),"},{"DocComment":"     ControlFlow::Break(ControlFlow::Break(3)),"},{"DocComment":" );"},{"DocComment":" ```"},{"Unknown":{"path":"unstable","args":"feature = \"try_trait_v2\", issue = \"84277\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":0}}],"output":{"Adt":[{"Adt":4},{"regions":[],"types":[{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":9}}}}}},"Residual"]},{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":9}}}}}},"Output"]}],"const_generics":[],"trait_refs":[null,null],"target":{"Item":{"Type":4}}}]}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":9}}}},"item_name":"branch","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":101,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["FromResidual",0]},{"Ident":["from_residual",0]}],"span":{"span":{"file_id":18,"beg":{"line":330,"col":4},"end":{"line":330,"col":42}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Constructs the type from a compatible `Residual` type."},{"DocComment":""},{"DocComment":" This should be implemented consistently with the `branch` method such"},{"DocComment":" that applying the `?` operator will get back an equivalent residual:"},{"DocComment":" `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`."},{"DocComment":" (The residual is not mandated to be *identical* when interconversion is involved.)"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #![feature(try_trait_v2)]"},{"DocComment":" use std::ops::{ControlFlow, FromResidual};"},{"DocComment":""},{"DocComment":" assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));"},{"DocComment":" assert_eq!(Option::<String>::from_residual(None), None);"},{"DocComment":" assert_eq!("},{"DocComment":"     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),"},{"DocComment":"     ControlFlow::Break(5),"},{"DocComment":" );"},{"DocComment":" ```"},{"Unknown":{"path":"unstable","args":"feature = \"try_trait_v2\", issue = \"84277\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"R"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":1}}],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":23,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":23}}}},"item_name":"from_residual","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,{"def_id":103,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Sum",0]},{"Ident":["sum",0]}],"span":{"span":{"file_id":23,"beg":{"line":21,"col":4},"end":{"line":21,"col":51}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Takes an iterator and generates `Self` from the elements by \"summing up\""},{"DocComment":" the items."}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"},{"index":2,"name":"I"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":23,"beg":{"line":21,"col":14},"end":{"line":21,"col":32}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[{"regions":[],"skip_binder":{"trait_ref":{"kind":{"Clause":{"Free":1}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},"type_name":"Item","ty":{"TypeVar":{"Free":1}}}}]},"inputs":[{"TypeVar":{"Free":2}}],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":17,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":17}}}},"item_name":"sum","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":104,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Product",0]},{"Ident":["product",0]}],"span":{"span":{"file_id":23,"beg":{"line":42,"col":4},"end":{"line":42,"col":55}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Takes an iterator and generates `Self` from the elements by multiplying"},{"DocComment":" the items."}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"},{"index":2,"name":"I"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":23,"beg":{"line":42,"col":18},"end":{"line":42,"col":36}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[{"regions":[],"skip_binder":{"trait_ref":{"kind":{"Clause":{"Free":1}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},"type_name":"Item","ty":{"TypeVar":{"Free":1}}}}]},"inputs":[{"TypeVar":{"Free":2}}],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":18,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":18}}}},"item_name":"product","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":105,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["FromIterator",0]},{"Ident":["from_iter",0]}],"span":{"span":{"file_id":15,"beg":{"line":152,"col":4},"end":{"line":152,"col":61}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Creates a value from an iterator."},{"DocComment":""},{"DocComment":" See the [module-level documentation] for more."},{"DocComment":""},{"DocComment":" [module-level documentation]: crate::iter"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let five_fives = std::iter::repeat(5).take(5);"},{"DocComment":""},{"DocComment":" let v = Vec::from_iter(five_fives);"},{"DocComment":""},{"DocComment":" assert_eq!(v, vec![5, 5, 5, 5, 5]);"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"},{"index":2,"name":"T"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":15,"beg":{"line":152,"col":20},"end":{"line":152,"col":42}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":6}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[{"regions":[],"skip_binder":{"trait_ref":{"kind":{"Clause":{"Free":1}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":6}}}}}},"type_name":"Item","ty":{"TypeVar":{"Free":1}}}}]},"inputs":[{"TypeVar":{"Free":2}}],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":8,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":8}}}},"item_name":"from_iter","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":106,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["IntoIterator",0]},{"Ident":["into_iter",0]}],"span":{"span":{"file_id":15,"beg":{"line":346,"col":4},"end":{"line":346,"col":41}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Creates an iterator from a value."},{"DocComment":""},{"DocComment":" See the [module-level documentation] for more."},{"DocComment":""},{"DocComment":" [module-level documentation]: crate::iter"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let v = [1, 2, 3];"},{"DocComment":" let mut iter = v.into_iter();"},{"DocComment":""},{"DocComment":" assert_eq!(Some(1), iter.next());"},{"DocComment":" assert_eq!(Some(2), iter.next());"},{"DocComment":" assert_eq!(Some(3), iter.next());"},{"DocComment":" assert_eq!(None, iter.next());"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":0}}],"output":{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":6}}}}}},"IntoIter"]}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":6}}}},"item_name":"into_iter","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":107,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["Extend",0]},{"Ident":["extend",0]}],"span":{"span":{"file_id":15,"beg":{"line":450,"col":4},"end":{"line":450,"col":61}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Extends a collection with the contents of an iterator."},{"DocComment":""},{"DocComment":" As this is the only required method for this trait, the [trait-level] docs"},{"DocComment":" contain more details."},{"DocComment":""},{"DocComment":" [trait-level]: Extend"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // You can extend a String with some chars:"},{"DocComment":" let mut message = String::from(\"abc\");"},{"DocComment":""},{"DocComment":" message.extend(['d', 'e', 'f'].iter());"},{"DocComment":""},{"DocComment":" assert_eq!(\"abcdef\", &message);"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"},{"index":2,"name":"T"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":15,"beg":{"line":450,"col":17},"end":{"line":450,"col":39}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":6}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[{"regions":[],"skip_binder":{"trait_ref":{"kind":{"Clause":{"Free":1}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":6}}}}}},"type_name":"Item","ty":{"TypeVar":{"Free":1}}}}]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Mut"]},{"TypeVar":{"Free":2}}],"output":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":11,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":11}}}},"item_name":"extend","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,{"def_id":111,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]},{"Ident":["next_back",0]}],"span":{"span":{"file_id":20,"beg":{"line":94,"col":4},"end":{"line":94,"col":50}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Removes and returns an element from the end of the iterator."},{"DocComment":""},{"DocComment":" Returns `None` when there are no more elements."},{"DocComment":""},{"DocComment":" The [trait-level] docs contain more details."},{"DocComment":""},{"DocComment":" [trait-level]: DoubleEndedIterator"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Basic usage:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let numbers = vec![1, 2, 3, 4, 5, 6];"},{"DocComment":""},{"DocComment":" let mut iter = numbers.iter();"},{"DocComment":""},{"DocComment":" assert_eq!(Some(&1), iter.next());"},{"DocComment":" assert_eq!(Some(&6), iter.next_back());"},{"DocComment":" assert_eq!(Some(&5), iter.next_back());"},{"DocComment":" assert_eq!(Some(&2), iter.next());"},{"DocComment":" assert_eq!(Some(&3), iter.next());"},{"DocComment":" assert_eq!(Some(&4), iter.next());"},{"DocComment":" assert_eq!(None, iter.next());"},{"DocComment":" assert_eq!(None, iter.next_back());"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" # Remarks"},{"DocComment":""},{"DocComment":" The elements yielded by `DoubleEndedIterator`'s methods may differ from"},{"DocComment":" the ones yielded by [`Iterator`]'s methods:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let vec = vec![(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b')];"},{"DocComment":" let uniq_by_fst_comp = || {"},{"DocComment":"     let mut seen = std::collections::HashSet::new();"},{"DocComment":"     vec.iter().copied().filter(move |x| seen.insert(x.0))"},{"DocComment":" };"},{"DocComment":""},{"DocComment":" assert_eq!(uniq_by_fst_comp().last(), Some((2, 'a')));"},{"DocComment":" assert_eq!(uniq_by_fst_comp().next_back(), Some((2, 'b')));"},{"DocComment":""},{"DocComment":" assert_eq!("},{"DocComment":"     uniq_by_fst_comp().fold(vec![], |mut v, x| {v.push(x); v}),"},{"DocComment":"     vec![(1, 'a'), (2, 'a')]"},{"DocComment":" );"},{"DocComment":" assert_eq!("},{"DocComment":"     uniq_by_fst_comp().rfold(vec![], |mut v, x| {v.push(x); v}),"},{"DocComment":"     vec![(2, 'b'), (1, 'c')]"},{"DocComment":" );"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Mut"]}],"output":{"Adt":[{"Adt":2},{"regions":[],"types":[{"TraitType":[{"kind":{"ParentClause":["SelfId",13,0]},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},"Item"]}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":2}}}]}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":13,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":13}}}},"item_name":"next_back","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,null,null,null,null,{"def_id":119,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["arith",0]},{"Impl":[{"Trait":1},171]},{"Ident":["mul",0]}],"span":{"span":{"file_id":14,"beg":{"line":35,"col":12},"end":{"line":35,"col":67}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"Unknown":{"path":"track_caller","args":null}}],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":"'a"}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Literal":{"Integer":"I32"}},"Shared"]},{"Literal":{"Integer":"I32"}}],"output":{"Literal":{"Integer":"I32"}}},"kind":{"TraitImpl":{"impl_ref":{"impl_id":1,"generics":{"regions":[{"Var":{"Free":0}}],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitImpl":1}}}},"trait_ref":{"trait_id":5,"generics":{"regions":[],"types":[{"Ref":[{"Var":{"Free":0}},{"Literal":{"Integer":"I32"}},"Shared"]},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":5}}}},"item_name":"mul","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":120,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["arith",0]},{"Impl":[{"Trait":2},137]},{"Ident":["mul",0]}],"span":{"span":{"file_id":13,"beg":{"line":342,"col":12},"end":{"line":342,"col":41}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"Unknown":{"path":"track_caller","args":null}}],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Literal":{"Integer":"I32"}},{"Literal":{"Integer":"I32"}}],"output":{"Literal":{"Integer":"I32"}}},"kind":{"TraitImpl":{"impl_ref":{"impl_id":2,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitImpl":2}}}},"trait_ref":{"trait_id":5,"generics":{"regions":[],"types":[{"Literal":{"Integer":"I32"}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":5}}}},"item_name":"mul","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":121,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]},{"Ident":["next",0]}],"span":{"span":{"file_id":10,"beg":{"line":156,"col":12},"end":{"line":156,"col":47}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":"'a"},{"index":1,"name":null}],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":1}},{"Adt":[{"Adt":1},{"regions":[{"Var":{"Free":0}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":1}}}]},"Mut"]}],"output":{"Adt":[{"Adt":2},{"regions":[],"types":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":2}}}]}},"kind":{"TraitImpl":{"impl_ref":{"impl_id":0,"generics":{"regions":[{"Var":{"Free":0}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"TraitImpl":0}}}},"trait_ref":{"trait_id":1,"generics":{"regions":[],"types":[{"Adt":[{"Adt":1},{"regions":[{"Var":{"Free":0}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":1}}}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}},"item_name":"next","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"global_decls":[],"trait_decls":[null,{"def_id":1,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]}],"span":{"span":{"file_id":8,"beg":{"line":39,"col":0},"end":{"line":39,"col":18}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" A trait for dealing with iterators."},{"DocComment":""},{"DocComment":" This is the main iterator trait. For more about the concept of iterators"},{"DocComment":" generally, please see the [module-level documentation]. In particular, you"},{"DocComment":" may want to know how to [implement `Iterator`][impl]."},{"DocComment":""},{"DocComment":" [module-level documentation]: crate::iter"},{"DocComment":" [impl]: crate::iter#implementing-iterator"},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(_Self = \"core::ops::range::RangeTo<Idx>\", note =\n\"you might have meant to use a bounded `Range`\"),\non(_Self = \"core::ops::range::RangeToInclusive<Idx>\", note =\n\"you might have meant to use a bounded `RangeInclusive`\"), label =\n\"`{Self}` is not an iterator\", message = \"`{Self}` is not an iterator\""}},{"Unknown":{"path":"doc","args":"notable_trait"}},{"Unknown":{"path":"rustc_diagnostic_item","args":null}},{"Unknown":{"path":"must_use","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null],"consts":[],"const_defaults":{},"types":["Item"],"type_defaults":{},"type_clauses":[],"required_methods":[["next",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":8,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":8}}}},"kind":{"TraitMethod":[1,"next"]}}]],"provided_methods":[["map",{"params":{"regions":[],"types":[{"index":0,"name":"B"},{"index":1,"name":"F"}],"const_generics":[],"trait_clauses":[null,null,null,{"clause_id":3,"span":{"span":{"file_id":8,"beg":{"line":760,"col":11},"end":{"line":760,"col":33}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,1]}},{"Adt":["Tuple",{"regions":[],"types":[{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},"Item"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[{"regions":[],"skip_binder":{"trait_ref":{"kind":{"ParentClause":[{"Clause":{"Bound":[1,3]}},2,0]},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":3,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[2,1]}},{"Adt":["Tuple",{"regions":[],"types":[{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},"Item"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":3}}}}}},"type_name":"Output","ty":{"TypeVar":{"Bound":[1,0]}}}}]},"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Bound":[0,0]}},{"TypeVar":{"Bound":[0,1]}}],"const_generics":[],"trait_refs":[null,null,null,{"kind":{"Clause":{"Bound":[0,3]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,1]}},{"Adt":["Tuple",{"regions":[],"types":[{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},"Item"]}],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}}}}],"target":{"Item":{"Fun":4}}}},"kind":{"TraitMethod":[1,"map"]}}]]},{"def_id":2,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnMut",0]}],"span":{"span":{"file_id":12,"beg":{"line":163,"col":0},"end":{"line":163,"col":42}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" The version of the call operator that takes a mutable receiver."},{"DocComment":""},{"DocComment":" Instances of `FnMut` can be called repeatedly and may mutate state."},{"DocComment":""},{"DocComment":" `FnMut` is implemented automatically by closures which take mutable"},{"DocComment":" references to captured variables, as well as all types that implement"},{"DocComment":" [`Fn`], e.g., (safe) [function pointers] (since `FnMut` is a supertrait of"},{"DocComment":" [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `&mut F`"},{"DocComment":" implements `FnMut`, too."},{"DocComment":""},{"DocComment":" Since [`FnOnce`] is a supertrait of `FnMut`, any instance of `FnMut` can be"},{"DocComment":" used where a [`FnOnce`] is expected, and since [`Fn`] is a subtrait of"},{"DocComment":" `FnMut`, any instance of [`Fn`] can be used where `FnMut` is expected."},{"DocComment":""},{"DocComment":" Use `FnMut` as a bound when you want to accept a parameter of function-like"},{"DocComment":" type and need to call it repeatedly, while allowing it to mutate state."},{"DocComment":" If you don't want the parameter to mutate state, use [`Fn`] as a"},{"DocComment":" bound; if you don't need to call it repeatedly, use [`FnOnce`]."},{"DocComment":""},{"DocComment":" See the [chapter on closures in *The Rust Programming Language*][book] for"},{"DocComment":" some more information on this topic."},{"DocComment":""},{"DocComment":" Also of note is the special syntax for `Fn` traits (e.g."},{"DocComment":" `Fn(usize, bool) -> usize`). Those interested in the technical details of"},{"DocComment":" this can refer to [the relevant section in the *Rustonomicon*][nomicon]."},{"DocComment":""},{"DocComment":" [book]: ../../book/ch13-01-closures.html"},{"DocComment":" [function pointers]: fn"},{"DocComment":" [nomicon]: ../../nomicon/hrtb.html"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ## Calling a mutably capturing closure"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let mut x = 5;"},{"DocComment":" {"},{"DocComment":"     let mut square_x = || x *= x;"},{"DocComment":"     square_x();"},{"DocComment":" }"},{"DocComment":" assert_eq!(x, 25);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## Using a `FnMut` parameter"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" fn do_twice<F>(mut func: F)"},{"DocComment":"     where F: FnMut()"},{"DocComment":" {"},{"DocComment":"     func();"},{"DocComment":"     func();"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let mut x: usize = 1;"},{"DocComment":" {"},{"DocComment":"     let add_two_to_x = || x += 2;"},{"DocComment":"     do_twice(add_two_to_x);"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" assert_eq!(x, 5);"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(Args = \"()\", note =\n\"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"),\non(_Self = \"unsafe fn\", note =\n\"unsafe function cannot be called generically without an unsafe block\", label\n= \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"), message =\n\"expected a `{Trait}` closure, found `{Self}`\", label =\n\"expected an `{Trait}` closure, found `{Self}`\""}},{"Unknown":{"path":"fundamental","args":null}},{"Unknown":{"path":"must_use","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Args"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[{"clause_id":0,"span":{"span":{"file_id":12,"beg":{"line":163,"col":30},"end":{"line":163,"col":42}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"trait_id":3,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":3}}}}}},null,null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[["call_mut",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":6,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":6}}}},"kind":{"TraitMethod":[2,"call_mut"]}}]],"provided_methods":[]},{"def_id":3,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnOnce",0]}],"span":{"span":{"file_id":12,"beg":{"line":242,"col":0},"end":{"line":242,"col":29}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" The version of the call operator that takes a by-value receiver."},{"DocComment":""},{"DocComment":" Instances of `FnOnce` can be called, but might not be callable multiple"},{"DocComment":" times. Because of this, if the only thing known about a type is that it"},{"DocComment":" implements `FnOnce`, it can only be called once."},{"DocComment":""},{"DocComment":" `FnOnce` is implemented automatically by closures that might consume captured"},{"DocComment":" variables, as well as all types that implement [`FnMut`], e.g., (safe)"},{"DocComment":" [function pointers] (since `FnOnce` is a supertrait of [`FnMut`])."},{"DocComment":""},{"DocComment":" Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of"},{"DocComment":" [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected."},{"DocComment":""},{"DocComment":" Use `FnOnce` as a bound when you want to accept a parameter of function-like"},{"DocComment":" type and only need to call it once. If you need to call the parameter"},{"DocComment":" repeatedly, use [`FnMut`] as a bound; if you also need it to not mutate"},{"DocComment":" state, use [`Fn`]."},{"DocComment":""},{"DocComment":" See the [chapter on closures in *The Rust Programming Language*][book] for"},{"DocComment":" some more information on this topic."},{"DocComment":""},{"DocComment":" Also of note is the special syntax for `Fn` traits (e.g."},{"DocComment":" `Fn(usize, bool) -> usize`). Those interested in the technical details of"},{"DocComment":" this can refer to [the relevant section in the *Rustonomicon*][nomicon]."},{"DocComment":""},{"DocComment":" [book]: ../../book/ch13-01-closures.html"},{"DocComment":" [function pointers]: fn"},{"DocComment":" [nomicon]: ../../nomicon/hrtb.html"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ## Using a `FnOnce` parameter"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" fn consume_with_relish<F>(func: F)"},{"DocComment":"     where F: FnOnce() -> String"},{"DocComment":" {"},{"DocComment":"     // `func` consumes its captured variables, so it cannot be run more"},{"DocComment":"     // than once."},{"DocComment":"     println!(\"Consumed: {}\", func());"},{"DocComment":""},{"DocComment":"     println!(\"Delicious!\");"},{"DocComment":""},{"DocComment":"     // Attempting to invoke `func()` again will throw a `use of moved"},{"DocComment":"     // value` error for `func`."},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let x = String::from(\"x\");"},{"DocComment":" let consume_and_return_x = move || x;"},{"DocComment":" consume_with_relish(consume_and_return_x);"},{"DocComment":""},{"DocComment":" // `consume_and_return_x` can no longer be invoked at this point"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(Args = \"()\", note =\n\"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"),\non(_Self = \"unsafe fn\", note =\n\"unsafe function cannot be called generically without an unsafe block\", label\n= \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"), message =\n\"expected a `{Trait}` closure, found `{Self}`\", label =\n\"expected an `{Trait}` closure, found `{Self}`\""}},{"Unknown":{"path":"fundamental","args":null}},{"Unknown":{"path":"must_use","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Args"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,null,null],"consts":[],"const_defaults":{},"types":["Output"],"type_defaults":{},"type_clauses":[],"required_methods":[["call_once",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":7,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":7}}}},"kind":{"TraitMethod":[3,"call_once"]}}]],"provided_methods":[]},null,{"def_id":5,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["arith",0]},{"Ident":["Mul",0]}],"span":{"span":{"file_id":13,"beg":{"line":315,"col":0},"end":{"line":315,"col":25}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" The multiplication operator `*`."},{"DocComment":""},{"DocComment":" Note that `Rhs` is `Self` by default, but this is not mandatory."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ## `Mul`tipliable rational numbers"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::ops::Mul;"},{"DocComment":""},{"DocComment":" // By the fundamental theorem of arithmetic, rational numbers in lowest"},{"DocComment":" // terms are unique. So, by keeping `Rational`s in reduced form, we can"},{"DocComment":" // derive `Eq` and `PartialEq`."},{"DocComment":" #[derive(Debug, Eq, PartialEq)]"},{"DocComment":" struct Rational {"},{"DocComment":"     numerator: usize,"},{"DocComment":"     denominator: usize,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Rational {"},{"DocComment":"     fn new(numerator: usize, denominator: usize) -> Self {"},{"DocComment":"         if denominator == 0 {"},{"DocComment":"             panic!(\"Zero is an invalid denominator!\");"},{"DocComment":"         }"},{"DocComment":""},{"DocComment":"         // Reduce to lowest terms by dividing by the greatest common"},{"DocComment":"         // divisor."},{"DocComment":"         let gcd = gcd(numerator, denominator);"},{"DocComment":"         Self {"},{"DocComment":"             numerator: numerator / gcd,"},{"DocComment":"             denominator: denominator / gcd,"},{"DocComment":"         }"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Mul for Rational {"},{"DocComment":"     // The multiplication of rational numbers is a closed operation."},{"DocComment":"     type Output = Self;"},{"DocComment":""},{"DocComment":"     fn mul(self, rhs: Self) -> Self {"},{"DocComment":"         let numerator = self.numerator * rhs.numerator;"},{"DocComment":"         let denominator = self.denominator * rhs.denominator;"},{"DocComment":"         Self::new(numerator, denominator)"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // Euclid's two-thousand-year-old algorithm for finding the greatest common"},{"DocComment":" // divisor."},{"DocComment":" fn gcd(x: usize, y: usize) -> usize {"},{"DocComment":"     let mut x = x;"},{"DocComment":"     let mut y = y;"},{"DocComment":"     while y != 0 {"},{"DocComment":"         let t = y;"},{"DocComment":"         y = x % y;"},{"DocComment":"         x = t;"},{"DocComment":"     }"},{"DocComment":"     x"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" assert_eq!(Rational::new(1, 2), Rational::new(2, 4));"},{"DocComment":" assert_eq!(Rational::new(2, 3) * Rational::new(3, 4),"},{"DocComment":"            Rational::new(1, 2));"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## Multiplying vectors by scalars as in linear algebra"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::ops::Mul;"},{"DocComment":""},{"DocComment":" struct Scalar { value: usize }"},{"DocComment":""},{"DocComment":" #[derive(Debug, PartialEq)]"},{"DocComment":" struct Vector { value: Vec<usize> }"},{"DocComment":""},{"DocComment":" impl Mul<Scalar> for Vector {"},{"DocComment":"     type Output = Self;"},{"DocComment":""},{"DocComment":"     fn mul(self, rhs: Scalar) -> Self::Output {"},{"DocComment":"         Self { value: self.value.iter().map(|v| v * rhs.value).collect() }"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let vector = Vector { value: vec![2, 4, 6] };"},{"DocComment":" let scalar = Scalar { value: 3 };"},{"DocComment":" assert_eq!(vector * scalar, Vector { value: vec![6, 12, 18] });"},{"DocComment":" ```"},{"Unknown":{"path":"diagnostic::on_unimplemented","args":"message = \"cannot multiply `{Self}` by `{Rhs}`\", label =\n\"no implementation for `{Self} * {Rhs}`\""}},{"Unknown":{"path":"doc","args":"alias = \"*\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Rhs"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,null],"consts":[],"const_defaults":{},"types":["Output"],"type_defaults":{},"type_clauses":[],"required_methods":[["mul",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":5,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":5}}}},"kind":{"TraitMethod":[5,"mul"]}}]],"provided_methods":[]},{"def_id":6,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["IntoIterator",0]}],"span":{"span":{"file_id":15,"beg":{"line":318,"col":0},"end":{"line":318,"col":22}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Conversion into an [`Iterator`]."},{"DocComment":""},{"DocComment":" By implementing `IntoIterator` for a type, you define how it will be"},{"DocComment":" converted to an iterator. This is common for types which describe a"},{"DocComment":" collection of some kind."},{"DocComment":""},{"DocComment":" One benefit of implementing `IntoIterator` is that your type will [work"},{"DocComment":" with Rust's `for` loop syntax](crate::iter#for-loops-and-intoiterator)."},{"DocComment":""},{"DocComment":" See also: [`FromIterator`]."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Basic usage:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let v = [1, 2, 3];"},{"DocComment":" let mut iter = v.into_iter();"},{"DocComment":""},{"DocComment":" assert_eq!(Some(1), iter.next());"},{"DocComment":" assert_eq!(Some(2), iter.next());"},{"DocComment":" assert_eq!(Some(3), iter.next());"},{"DocComment":" assert_eq!(None, iter.next());"},{"DocComment":" ```"},{"DocComment":" Implementing `IntoIterator` for your type:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // A sample collection, that's just a wrapper over Vec<T>"},{"DocComment":" #[derive(Debug)]"},{"DocComment":" struct MyCollection(Vec<i32>);"},{"DocComment":""},{"DocComment":" // Let's give it some methods so we can create one and add things"},{"DocComment":" // to it."},{"DocComment":" impl MyCollection {"},{"DocComment":"     fn new() -> MyCollection {"},{"DocComment":"         MyCollection(Vec::new())"},{"DocComment":"     }"},{"DocComment":""},{"DocComment":"     fn add(&mut self, elem: i32) {"},{"DocComment":"         self.0.push(elem);"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // and we'll implement IntoIterator"},{"DocComment":" impl IntoIterator for MyCollection {"},{"DocComment":"     type Item = i32;"},{"DocComment":"     type IntoIter = std::vec::IntoIter<Self::Item>;"},{"DocComment":""},{"DocComment":"     fn into_iter(self) -> Self::IntoIter {"},{"DocComment":"         self.0.into_iter()"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // Now we can make a new collection..."},{"DocComment":" let mut c = MyCollection::new();"},{"DocComment":""},{"DocComment":" // ... add some stuff to it ..."},{"DocComment":" c.add(0);"},{"DocComment":" c.add(1);"},{"DocComment":" c.add(2);"},{"DocComment":""},{"DocComment":" // ... and then turn it into an Iterator:"},{"DocComment":" for (i, n) in c.into_iter().enumerate() {"},{"DocComment":"     assert_eq!(i as i32, n);"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" It is common to use `IntoIterator` as a trait bound. This allows"},{"DocComment":" the input collection type to change, so long as it is still an"},{"DocComment":" iterator. Additional bounds can be specified by restricting on"},{"DocComment":" `Item`:"},{"DocComment":""},{"DocComment":" ```rust"},{"DocComment":" fn collect_as_strings<T>(collection: T) -> Vec<String>"},{"DocComment":" where"},{"DocComment":"     T: IntoIterator,"},{"DocComment":"     T::Item: std::fmt::Debug,"},{"DocComment":" {"},{"DocComment":"     collection"},{"DocComment":"         .into_iter()"},{"DocComment":"         .map(|item| format!(\"{item:?}\"))"},{"DocComment":"         .collect()"},{"DocComment":" }"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_diagnostic_item","args":null}},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(_Self = \"core::ops::range::RangeTo<Idx>\", label =\n\"if you meant to iterate until a value, add a starting value\", note =\n\"`..end` is a `RangeTo`, which cannot be iterated on; you might have meant to have a \\\n              bounded `Range`: `0..end`\"),\non(_Self = \"core::ops::range::RangeToInclusive<Idx>\", label =\n\"if you meant to iterate until a value (including it), add a starting value\",\nnote =\n\"`..=end` is a `RangeToInclusive`, which cannot be iterated on; you might have meant \\\n              to have a bounded `RangeInclusive`: `0..=end`\"),\non(_Self = \"[]\", label =\n\"`{Self}` is not an iterator; try calling `.into_iter()` or `.iter()`\"),\non(_Self = \"&[]\", label =\n\"`{Self}` is not an iterator; try calling `.iter()`\"),\non(_Self = \"alloc::vec::Vec<T, A>\", label =\n\"`{Self}` is not an iterator; try calling `.into_iter()` or `.iter()`\"),\non(_Self = \"&str\", label =\n\"`{Self}` is not an iterator; try calling `.chars()` or `.bytes()`\"),\non(_Self = \"alloc::string::String\", label =\n\"`{Self}` is not an iterator; try calling `.chars()` or `.bytes()`\"),\non(_Self = \"{integral}\", note =\n\"if you want to iterate between `start` until a value `end`, use the exclusive range \\\n              syntax `start..end` or the inclusive range syntax `start..=end`\"),\non(_Self = \"{float}\", note =\n\"if you want to iterate between `start` until a value `end`, use the exclusive range \\\n              syntax `start..end` or the inclusive range syntax `start..=end`\"),\nlabel = \"`{Self}` is not an iterator\", message = \"`{Self}` is not an iterator\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[{"regions":[],"skip_binder":{"trait_ref":{"kind":{"ParentClause":["SelfId",6,2]},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":6}}}}}},"IntoIter"]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},"type_name":"Item","ty":{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":6}}}}}},"Item"]}}}]},"parent_clauses":[null,null,{"clause_id":2,"span":{"span":{"file_id":15,"beg":{"line":325,"col":19},"end":{"line":325,"col":46}},"generated_from_span":null},"origin":{"TraitItem":"IntoIter"},"trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":6}}}}}},"IntoIter"]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"consts":[],"const_defaults":{},"types":["Item","IntoIter"],"type_defaults":{},"type_clauses":[],"required_methods":[["into_iter",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":106,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":106}}}},"kind":{"TraitMethod":[6,"into_iter"]}}]],"provided_methods":[]},{"def_id":7,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["Clone",0]}],"span":{"span":{"file_id":16,"beg":{"line":149,"col":0},"end":{"line":149,"col":22}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" A common trait for the ability to explicitly duplicate an object."},{"DocComment":""},{"DocComment":" Differs from [`Copy`] in that [`Copy`] is implicit and an inexpensive bit-wise copy, while"},{"DocComment":" `Clone` is always explicit and may or may not be expensive. In order to enforce"},{"DocComment":" these characteristics, Rust does not allow you to reimplement [`Copy`], but you"},{"DocComment":" may reimplement `Clone` and run arbitrary code."},{"DocComment":""},{"DocComment":" Since `Clone` is more general than [`Copy`], you can automatically make anything"},{"DocComment":" [`Copy`] be `Clone` as well."},{"DocComment":""},{"DocComment":" ## Derivable"},{"DocComment":""},{"DocComment":" This trait can be used with `#[derive]` if all fields are `Clone`. The `derive`d"},{"DocComment":" implementation of [`Clone`] calls [`clone`] on each field."},{"DocComment":""},{"DocComment":" [`clone`]: Clone::clone"},{"DocComment":""},{"DocComment":" For a generic struct, `#[derive]` implements `Clone` conditionally by adding bound `Clone` on"},{"DocComment":" generic parameters."},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // `derive` implements Clone for Reading<T> when T is Clone."},{"DocComment":" #[derive(Clone)]"},{"DocComment":" struct Reading<T> {"},{"DocComment":"     frequency: T,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## How can I implement `Clone`?"},{"DocComment":""},{"DocComment":" Types that are [`Copy`] should have a trivial implementation of `Clone`. More formally:"},{"DocComment":" if `T: Copy`, `x: T`, and `y: &T`, then `let x = y.clone();` is equivalent to `let x = *y;`."},{"DocComment":" Manual implementations should be careful to uphold this invariant; however, unsafe code"},{"DocComment":" must not rely on it to ensure memory safety."},{"DocComment":""},{"DocComment":" An example is a generic struct holding a function pointer. In this case, the"},{"DocComment":" implementation of `Clone` cannot be `derive`d, but can be implemented as:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" struct Generate<T>(fn() -> T);"},{"DocComment":""},{"DocComment":" impl<T> Copy for Generate<T> {}"},{"DocComment":""},{"DocComment":" impl<T> Clone for Generate<T> {"},{"DocComment":"     fn clone(&self) -> Self {"},{"DocComment":"         *self"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" If we `derive`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(Copy, Clone)]"},{"DocComment":" struct Generate<T>(fn() -> T);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" the auto-derived implementations will have unnecessary `T: Copy` and `T: Clone` bounds:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # struct Generate<T>(fn() -> T);"},{"DocComment":""},{"DocComment":" // Automatically derived"},{"DocComment":" impl<T: Copy> Copy for Generate<T> { }"},{"DocComment":""},{"DocComment":" // Automatically derived"},{"DocComment":" impl<T: Clone> Clone for Generate<T> {"},{"DocComment":"     fn clone(&self) -> Generate<T> {"},{"DocComment":"         Generate(Clone::clone(&self.0))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" The bounds are unnecessary because clearly the function itself should be"},{"DocComment":" copy- and cloneable even if its return type is not:"},{"DocComment":""},{"DocComment":" ```compile_fail,E0599"},{"DocComment":" #[derive(Copy, Clone)]"},{"DocComment":" struct Generate<T>(fn() -> T);"},{"DocComment":""},{"DocComment":" struct NotCloneable;"},{"DocComment":""},{"DocComment":" fn generate_not_cloneable() -> NotCloneable {"},{"DocComment":"     NotCloneable"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" Generate(generate_not_cloneable).clone(); // error: trait bounds were not satisfied"},{"DocComment":" // Note: With the manual implementations the above line will compile."},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## Additional implementors"},{"DocComment":""},{"DocComment":" In addition to the [implementors listed below][impls],"},{"DocComment":" the following types also implement `Clone`:"},{"DocComment":""},{"DocComment":" * Function item types (i.e., the distinct types defined for each function)"},{"DocComment":" * Function pointer types (e.g., `fn() -> i32`)"},{"DocComment":" * Closure types, if they capture no value from the environment"},{"DocComment":"   or if all such captured values implement `Clone` themselves."},{"DocComment":"   Note that variables captured by shared reference always implement `Clone`"},{"DocComment":"   (even if the referent doesn't),"},{"DocComment":"   while variables captured by mutable reference never implement `Clone`."},{"DocComment":""},{"DocComment":" [impls]: #implementors"},{"Unknown":{"path":"rustc_diagnostic_item","args":null}},{"Unknown":{"path":"rustc_trivial_field_reads","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[["clone",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":84,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":84}}}},"kind":{"TraitMethod":[7,"clone"]}}]],"provided_methods":[]},{"def_id":8,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["FromIterator",0]}],"span":{"span":{"file_id":15,"beg":{"line":134,"col":0},"end":{"line":134,"col":32}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Conversion from an [`Iterator`]."},{"DocComment":""},{"DocComment":" By implementing `FromIterator` for a type, you define how it will be"},{"DocComment":" created from an iterator. This is common for types which describe a"},{"DocComment":" collection of some kind."},{"DocComment":""},{"DocComment":" If you want to create a collection from the contents of an iterator, the"},{"DocComment":" [`Iterator::collect()`] method is preferred. However, when you need to"},{"DocComment":" specify the container type, [`FromIterator::from_iter()`] can be more"},{"DocComment":" readable than using a turbofish (e.g. `::<Vec<_>>()`). See the"},{"DocComment":" [`Iterator::collect()`] documentation for more examples of its use."},{"DocComment":""},{"DocComment":" See also: [`IntoIterator`]."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Basic usage:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let five_fives = std::iter::repeat(5).take(5);"},{"DocComment":""},{"DocComment":" let v = Vec::from_iter(five_fives);"},{"DocComment":""},{"DocComment":" assert_eq!(v, vec![5, 5, 5, 5, 5]);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Using [`Iterator::collect()`] to implicitly use `FromIterator`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let five_fives = std::iter::repeat(5).take(5);"},{"DocComment":""},{"DocComment":" let v: Vec<i32> = five_fives.collect();"},{"DocComment":""},{"DocComment":" assert_eq!(v, vec![5, 5, 5, 5, 5]);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Using [`FromIterator::from_iter()`] as a more readable alternative to"},{"DocComment":" [`Iterator::collect()`]:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::collections::VecDeque;"},{"DocComment":" let first = (0..10).collect::<VecDeque<i32>>();"},{"DocComment":" let second = VecDeque::from_iter(0..10);"},{"DocComment":""},{"DocComment":" assert_eq!(first, second);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Implementing `FromIterator` for your type:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // A sample collection, that's just a wrapper over Vec<T>"},{"DocComment":" #[derive(Debug)]"},{"DocComment":" struct MyCollection(Vec<i32>);"},{"DocComment":""},{"DocComment":" // Let's give it some methods so we can create one and add things"},{"DocComment":" // to it."},{"DocComment":" impl MyCollection {"},{"DocComment":"     fn new() -> MyCollection {"},{"DocComment":"         MyCollection(Vec::new())"},{"DocComment":"     }"},{"DocComment":""},{"DocComment":"     fn add(&mut self, elem: i32) {"},{"DocComment":"         self.0.push(elem);"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // and we'll implement FromIterator"},{"DocComment":" impl FromIterator<i32> for MyCollection {"},{"DocComment":"     fn from_iter<I: IntoIterator<Item=i32>>(iter: I) -> Self {"},{"DocComment":"         let mut c = MyCollection::new();"},{"DocComment":""},{"DocComment":"         for i in iter {"},{"DocComment":"             c.add(i);"},{"DocComment":"         }"},{"DocComment":""},{"DocComment":"         c"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // Now we can make a new iterator..."},{"DocComment":" let iter = (0..5).into_iter();"},{"DocComment":""},{"DocComment":" // ... and make a MyCollection out of it"},{"DocComment":" let c = MyCollection::from_iter(iter);"},{"DocComment":""},{"DocComment":" assert_eq!(c.0, vec![0, 1, 2, 3, 4]);"},{"DocComment":""},{"DocComment":" // collect works too!"},{"DocComment":""},{"DocComment":" let iter = (0..5).into_iter();"},{"DocComment":" let c: MyCollection = iter.collect();"},{"DocComment":""},{"DocComment":" assert_eq!(c.0, vec![0, 1, 2, 3, 4]);"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(_Self = \"&[{A}]\", message =\n\"a slice of type `{Self}` cannot be built since we need to store the elements somewhere\",\nlabel = \"try explicitly collecting into a `Vec<{A}>`\",),\non(all(A = \"{integer}\", any(_Self = \"&[{integral}]\",)), message =\n\"a slice of type `{Self}` cannot be built since we need to store the elements somewhere\",\nlabel = \"try explicitly collecting into a `Vec<{A}>`\",),\non(_Self = \"[{A}]\", message =\n\"a slice of type `{Self}` cannot be built since `{Self}` has no definite size\",\nlabel = \"try explicitly collecting into a `Vec<{A}>`\",),\non(all(A = \"{integer}\", any(_Self = \"[{integral}]\",)), message =\n\"a slice of type `{Self}` cannot be built since `{Self}` has no definite size\",\nlabel = \"try explicitly collecting into a `Vec<{A}>`\",),\non(_Self = \"[{A}; _]\", message =\n\"an array of type `{Self}` cannot be built directly from an iterator\", label =\n\"try collecting into a `Vec<{A}>`, then using `.try_into()`\",),\non(all(A = \"{integer}\", any(_Self = \"[{integral}; _]\",)), message =\n\"an array of type `{Self}` cannot be built directly from an iterator\", label =\n\"try collecting into a `Vec<{A}>`, then using `.try_into()`\",), message =\n\"a value of type `{Self}` cannot be built from an iterator \\\n               over elements of type `{A}`\",\nlabel =\n\"value of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\""}},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[["from_iter",{"params":{"regions":[],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":15,"beg":{"line":152,"col":20},"end":{"line":152,"col":42}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":6}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[{"regions":[],"skip_binder":{"trait_ref":{"kind":{"Clause":{"Bound":[1,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[2,0]}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":6}}}}}},"type_name":"Item","ty":{"TypeVar":{"Free":1}}}}]},"skip_binder":{"id":105,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Bound":[0,0]}}],"const_generics":[],"trait_refs":[null,{"kind":{"Clause":{"Bound":[0,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":6}}}}}}],"target":{"Item":{"Fun":105}}}},"kind":{"TraitMethod":[8,"from_iter"]}}]],"provided_methods":[]},{"def_id":9,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Try",0]}],"span":{"span":{"file_id":18,"beg":{"line":131,"col":0},"end":{"line":131,"col":27}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" The `?` operator and `try {}` blocks."},{"DocComment":""},{"DocComment":" `try_*` methods typically involve a type implementing this trait.  For"},{"DocComment":" example, the closures passed to [`Iterator::try_fold`] and"},{"DocComment":" [`Iterator::try_for_each`] must return such a type."},{"DocComment":""},{"DocComment":" `Try` types are typically those containing two or more categories of values,"},{"DocComment":" some subset of which are so commonly handled via early returns that it's"},{"DocComment":" worth providing a terse (but still visible) syntax to make that easy."},{"DocComment":""},{"DocComment":" This is most often seen for error handling with [`Result`] and [`Option`]."},{"DocComment":" The quintessential implementation of this trait is on [`ControlFlow`]."},{"DocComment":""},{"DocComment":" # Using `Try` in Generic Code"},{"DocComment":""},{"DocComment":" `Iterator::try_fold` was stabilized to call back in Rust 1.27, but"},{"DocComment":" this trait is much newer.  To illustrate the various associated types and"},{"DocComment":" methods, let's implement our own version."},{"DocComment":""},{"DocComment":" As a reminder, an infallible version of a fold looks something like this:"},{"DocComment":" ```"},{"DocComment":" fn simple_fold<A, T>("},{"DocComment":"     iter: impl Iterator<Item = T>,"},{"DocComment":"     mut accum: A,"},{"DocComment":"     mut f: impl FnMut(A, T) -> A,"},{"DocComment":" ) -> A {"},{"DocComment":"     for x in iter {"},{"DocComment":"         accum = f(accum, x);"},{"DocComment":"     }"},{"DocComment":"     accum"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" So instead of `f` returning just an `A`, we'll need it to return some other"},{"DocComment":" type that produces an `A` in the \"don't short circuit\" path.  Conveniently,"},{"DocComment":" that's also the type we need to return from the function."},{"DocComment":""},{"DocComment":" Let's add a new generic parameter `R` for that type, and bound it to the"},{"DocComment":" output type that we want:"},{"DocComment":" ```"},{"DocComment":" # #![feature(try_trait_v2)]"},{"DocComment":" # use std::ops::Try;"},{"DocComment":" fn simple_try_fold_1<A, T, R: Try<Output = A>>("},{"DocComment":"     iter: impl Iterator<Item = T>,"},{"DocComment":"     mut accum: A,"},{"DocComment":"     mut f: impl FnMut(A, T) -> R,"},{"DocComment":" ) -> R {"},{"DocComment":"     todo!()"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" If we get through the entire iterator, we need to wrap up the accumulator"},{"DocComment":" into the return type using [`Try::from_output`]:"},{"DocComment":" ```"},{"DocComment":" # #![feature(try_trait_v2)]"},{"DocComment":" # use std::ops::{ControlFlow, Try};"},{"DocComment":" fn simple_try_fold_2<A, T, R: Try<Output = A>>("},{"DocComment":"     iter: impl Iterator<Item = T>,"},{"DocComment":"     mut accum: A,"},{"DocComment":"     mut f: impl FnMut(A, T) -> R,"},{"DocComment":" ) -> R {"},{"DocComment":"     for x in iter {"},{"DocComment":"         let cf = f(accum, x).branch();"},{"DocComment":"         match cf {"},{"DocComment":"             ControlFlow::Continue(a) => accum = a,"},{"DocComment":"             ControlFlow::Break(_) => todo!(),"},{"DocComment":"         }"},{"DocComment":"     }"},{"DocComment":"     R::from_output(accum)"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" We'll also need [`FromResidual::from_residual`] to turn the residual back"},{"DocComment":" into the original type.  But because it's a supertrait of `Try`, we don't"},{"DocComment":" need to mention it in the bounds.  All types which implement `Try` can be"},{"DocComment":" recreated from their corresponding residual, so we'll just call it:"},{"DocComment":" ```"},{"DocComment":" # #![feature(try_trait_v2)]"},{"DocComment":" # use std::ops::{ControlFlow, Try};"},{"DocComment":" pub fn simple_try_fold_3<A, T, R: Try<Output = A>>("},{"DocComment":"     iter: impl Iterator<Item = T>,"},{"DocComment":"     mut accum: A,"},{"DocComment":"     mut f: impl FnMut(A, T) -> R,"},{"DocComment":" ) -> R {"},{"DocComment":"     for x in iter {"},{"DocComment":"         let cf = f(accum, x).branch();"},{"DocComment":"         match cf {"},{"DocComment":"             ControlFlow::Continue(a) => accum = a,"},{"DocComment":"             ControlFlow::Break(r) => return R::from_residual(r),"},{"DocComment":"         }"},{"DocComment":"     }"},{"DocComment":"     R::from_output(accum)"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" But this \"call `branch`, then `match` on it, and `return` if it was a"},{"DocComment":" `Break`\" is exactly what happens inside the `?` operator.  So rather than"},{"DocComment":" do all this manually, we can just use `?` instead:"},{"DocComment":" ```"},{"DocComment":" # #![feature(try_trait_v2)]"},{"DocComment":" # use std::ops::Try;"},{"DocComment":" fn simple_try_fold<A, T, R: Try<Output = A>>("},{"DocComment":"     iter: impl Iterator<Item = T>,"},{"DocComment":"     mut accum: A,"},{"DocComment":"     mut f: impl FnMut(A, T) -> R,"},{"DocComment":" ) -> R {"},{"DocComment":"     for x in iter {"},{"DocComment":"         accum = f(accum, x)?;"},{"DocComment":"     }"},{"DocComment":"     R::from_output(accum)"},{"DocComment":" }"},{"DocComment":" ```"},{"Unknown":{"path":"unstable","args":"feature = \"try_trait_v2\", issue = \"84277\""}},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(all(from_desugaring = \"TryBlock\"), message =\n\"a `try` block must return `Result` or `Option` \\\n                    (or another type that implements `{Try}`)\",\nlabel =\n\"could not wrap the final value of the block as `{Self}` doesn't implement `Try`\",),\non(all(from_desugaring = \"QuestionMark\"), message =\n\"the `?` operator can only be applied to values that implement `{Try}`\", label\n= \"the `?` operator cannot be applied to type `{Self}`\")"}},{"Unknown":{"path":"doc","args":"alias = \"?\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[{"clause_id":0,"span":{"span":{"file_id":18,"beg":{"line":131,"col":15},"end":{"line":131,"col":27}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"trait_id":23,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":9}}}}}},"Residual"]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":23}}}}}},null,null],"consts":[],"const_defaults":{},"types":["Output","Residual"],"type_defaults":{},"type_clauses":[],"required_methods":[["from_output",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":99,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":99}}}},"kind":{"TraitMethod":[9,"from_output"]}}],["branch",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":100,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":100}}}},"kind":{"TraitMethod":[9,"branch"]}}]],"provided_methods":[]},{"def_id":10,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Residual",0]}],"span":{"span":{"file_id":18,"beg":{"line":359,"col":0},"end":{"line":359,"col":21}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Allows retrieving the canonical type implementing [`Try`] that has this type"},{"DocComment":" as its residual and allows it to hold an `O` as its output."},{"DocComment":""},{"DocComment":" If you think of the `Try` trait as splitting a type into its [`Try::Output`]"},{"DocComment":" and [`Try::Residual`] components, this allows putting them back together."},{"DocComment":""},{"DocComment":" For example,"},{"DocComment":" `Result<T, E>: Try<Output = T, Residual = Result<Infallible, E>>`,"},{"DocComment":" and in the other direction,"},{"DocComment":" `<Result<Infallible, E> as Residual<T>>::TryType = Result<T, E>`."},{"Unknown":{"path":"unstable","args":"feature = \"try_trait_v2_residual\", issue = \"91285\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"O"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[{"regions":[],"skip_binder":{"trait_ref":{"kind":{"ParentClause":["SelfId",10,2]},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":9,"generics":{"regions":[],"types":[{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":10}}}}}},"TryType"]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":9}}}}}},"type_name":"Output","ty":{"TypeVar":{"Free":1}}}},{"regions":[],"skip_binder":{"trait_ref":{"kind":{"ParentClause":["SelfId",10,2]},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":9,"generics":{"regions":[],"types":[{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":10}}}}}},"TryType"]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":9}}}}}},"type_name":"Residual","ty":{"TypeVar":{"Free":0}}}}]},"parent_clauses":[null,null,{"clause_id":2,"span":{"span":{"file_id":18,"beg":{"line":362,"col":18},"end":{"line":362,"col":50}},"generated_from_span":null},"origin":{"TraitItem":"TryType"},"trait_":{"regions":[],"skip_binder":{"trait_id":9,"generics":{"regions":[],"types":[{"TraitType":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":10}}}}}},"TryType"]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":9}}}}}}],"consts":[],"const_defaults":{},"types":["TryType"],"type_defaults":{},"type_clauses":[],"required_methods":[],"provided_methods":[]},{"def_id":11,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["Extend",0]}],"span":{"span":{"file_id":15,"beg":{"line":431,"col":0},"end":{"line":431,"col":19}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Extend a collection with the contents of an iterator."},{"DocComment":""},{"DocComment":" Iterators produce a series of values, and collections can also be thought"},{"DocComment":" of as a series of values. The `Extend` trait bridges this gap, allowing you"},{"DocComment":" to extend a collection by including the contents of that iterator. When"},{"DocComment":" extending a collection with an already existing key, that entry is updated"},{"DocComment":" or, in the case of collections that permit multiple entries with equal"},{"DocComment":" keys, that entry is inserted."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Basic usage:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // You can extend a String with some chars:"},{"DocComment":" let mut message = String::from(\"The first three letters are: \");"},{"DocComment":""},{"DocComment":" message.extend(&['a', 'b', 'c']);"},{"DocComment":""},{"DocComment":" assert_eq!(\"abc\", &message[29..32]);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Implementing `Extend`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // A sample collection, that's just a wrapper over Vec<T>"},{"DocComment":" #[derive(Debug)]"},{"DocComment":" struct MyCollection(Vec<i32>);"},{"DocComment":""},{"DocComment":" // Let's give it some methods so we can create one and add things"},{"DocComment":" // to it."},{"DocComment":" impl MyCollection {"},{"DocComment":"     fn new() -> MyCollection {"},{"DocComment":"         MyCollection(Vec::new())"},{"DocComment":"     }"},{"DocComment":""},{"DocComment":"     fn add(&mut self, elem: i32) {"},{"DocComment":"         self.0.push(elem);"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // since MyCollection has a list of i32s, we implement Extend for i32"},{"DocComment":" impl Extend<i32> for MyCollection {"},{"DocComment":""},{"DocComment":"     // This is a bit simpler with the concrete type signature: we can call"},{"DocComment":"     // extend on anything which can be turned into an Iterator which gives"},{"DocComment":"     // us i32s. Because we need i32s to put into MyCollection."},{"DocComment":"     fn extend<T: IntoIterator<Item=i32>>(&mut self, iter: T) {"},{"DocComment":""},{"DocComment":"         // The implementation is very straightforward: loop through the"},{"DocComment":"         // iterator, and add() each element to ourselves."},{"DocComment":"         for elem in iter {"},{"DocComment":"             self.add(elem);"},{"DocComment":"         }"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let mut c = MyCollection::new();"},{"DocComment":""},{"DocComment":" c.add(5);"},{"DocComment":" c.add(6);"},{"DocComment":" c.add(7);"},{"DocComment":""},{"DocComment":" // let's extend our collection with three more numbers"},{"DocComment":" c.extend(vec![1, 2, 3]);"},{"DocComment":""},{"DocComment":" // we've added these elements onto the end"},{"DocComment":" assert_eq!(\"MyCollection([5, 6, 7, 1, 2, 3])\", format!(\"{c:?}\"));"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[["extend",{"params":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":15,"beg":{"line":450,"col":17},"end":{"line":450,"col":39}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":6}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[{"regions":[],"skip_binder":{"trait_ref":{"kind":{"Clause":{"Bound":[1,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[2,0]}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":6}}}}}},"type_name":"Item","ty":{"TypeVar":{"Free":1}}}}]},"skip_binder":{"id":107,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Bound":[0,0]}}],"const_generics":[],"trait_refs":[null,{"kind":{"Clause":{"Bound":[0,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":6}}}}}}],"target":{"Item":{"Fun":107}}}},"kind":{"TraitMethod":[11,"extend"]}}]],"provided_methods":[]},{"def_id":12,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["default",0]},{"Ident":["Default",0]}],"span":{"span":{"file_id":19,"beg":{"line":107,"col":0},"end":{"line":107,"col":24}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" A trait for giving a type a useful default value."},{"DocComment":""},{"DocComment":" Sometimes, you want to fall back to some kind of default value, and"},{"DocComment":" don't particularly care what it is. This comes up often with `struct`s"},{"DocComment":" that define a set of options:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #[allow(dead_code)]"},{"DocComment":" struct SomeOptions {"},{"DocComment":"     foo: i32,"},{"DocComment":"     bar: f32,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" How can we define some default values? You can use `Default`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #[allow(dead_code)]"},{"DocComment":" #[derive(Default)]"},{"DocComment":" struct SomeOptions {"},{"DocComment":"     foo: i32,"},{"DocComment":"     bar: f32,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" fn main() {"},{"DocComment":"     let options: SomeOptions = Default::default();"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Now, you get all of the default values. Rust implements `Default` for various primitives types."},{"DocComment":""},{"DocComment":" If you want to override a particular option, but still retain the other defaults:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #[allow(dead_code)]"},{"DocComment":" # #[derive(Default)]"},{"DocComment":" # struct SomeOptions {"},{"DocComment":" #     foo: i32,"},{"DocComment":" #     bar: f32,"},{"DocComment":" # }"},{"DocComment":" fn main() {"},{"DocComment":"     let options = SomeOptions { foo: 42, ..Default::default() };"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## Derivable"},{"DocComment":""},{"DocComment":" This trait can be used with `#[derive]` if all of the type's fields implement"},{"DocComment":" `Default`. When `derive`d, it will use the default value for each field's type."},{"DocComment":""},{"DocComment":" ### `enum`s"},{"DocComment":""},{"DocComment":" When using `#[derive(Default)]` on an `enum`, you need to choose which unit variant will be"},{"DocComment":" default. You do this by placing the `#[default]` attribute on the variant."},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(Default)]"},{"DocComment":" enum Kind {"},{"DocComment":"     #[default]"},{"DocComment":"     A,"},{"DocComment":"     B,"},{"DocComment":"     C,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" You cannot use the `#[default]` attribute on non-unit or non-exhaustive variants."},{"DocComment":""},{"DocComment":" The `#[default]` attribute was stabilized in Rust 1.62.0."},{"DocComment":""},{"DocComment":" ## How can I implement `Default`?"},{"DocComment":""},{"DocComment":" Provide an implementation for the `default()` method that returns the value of"},{"DocComment":" your type that should be the default:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #![allow(dead_code)]"},{"DocComment":" enum Kind {"},{"DocComment":"     A,"},{"DocComment":"     B,"},{"DocComment":"     C,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Default for Kind {"},{"DocComment":"     fn default() -> Self { Kind::A }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #[allow(dead_code)]"},{"DocComment":" #[derive(Default)]"},{"DocComment":" struct SomeOptions {"},{"DocComment":"     foo: i32,"},{"DocComment":"     bar: f32,"},{"DocComment":" }"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_diagnostic_item","args":null}},{"Unknown":{"path":"rustc_trivial_field_reads","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[["default",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":98,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":98}}}},"kind":{"TraitMethod":[12,"default"]}}]],"provided_methods":[]},{"def_id":13,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]}],"span":{"span":{"file_id":20,"beg":{"line":41,"col":0},"end":{"line":41,"col":39}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" An iterator able to yield elements from both ends."},{"DocComment":""},{"DocComment":" Something that implements `DoubleEndedIterator` has one extra capability"},{"DocComment":" over something that implements [`Iterator`]: the ability to also take"},{"DocComment":" `Item`s from the back, as well as the front."},{"DocComment":""},{"DocComment":" It is important to note that both back and forth work on the same range,"},{"DocComment":" and do not cross: iteration is over when they meet in the middle."},{"DocComment":""},{"DocComment":" In a similar fashion to the [`Iterator`] protocol, once a"},{"DocComment":" `DoubleEndedIterator` returns [`None`] from a [`next_back()`], calling it"},{"DocComment":" again may or may not ever return [`Some`] again. [`next()`] and"},{"DocComment":" [`next_back()`] are interchangeable for this purpose."},{"DocComment":""},{"DocComment":" [`next_back()`]: DoubleEndedIterator::next_back"},{"DocComment":" [`next()`]: Iterator::next"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Basic usage:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let numbers = vec![1, 2, 3, 4, 5, 6];"},{"DocComment":""},{"DocComment":" let mut iter = numbers.iter();"},{"DocComment":""},{"DocComment":" assert_eq!(Some(&1), iter.next());"},{"DocComment":" assert_eq!(Some(&6), iter.next_back());"},{"DocComment":" assert_eq!(Some(&5), iter.next_back());"},{"DocComment":" assert_eq!(Some(&2), iter.next());"},{"DocComment":" assert_eq!(Some(&3), iter.next());"},{"DocComment":" assert_eq!(Some(&4), iter.next());"},{"DocComment":" assert_eq!(None, iter.next());"},{"DocComment":" assert_eq!(None, iter.next_back());"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[{"clause_id":0,"span":{"span":{"file_id":20,"beg":{"line":41,"col":31},"end":{"line":41,"col":39}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[["next_back",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":111,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":111}}}},"kind":{"TraitMethod":[13,"next_back"]}}]],"provided_methods":[]},{"def_id":14,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["exact_size",0]},{"Ident":["ExactSizeIterator",0]}],"span":{"span":{"file_id":21,"beg":{"line":86,"col":0},"end":{"line":86,"col":37}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" An iterator that knows its exact length."},{"DocComment":""},{"DocComment":" Many [`Iterator`]s don't know how many times they will iterate, but some do."},{"DocComment":" If an iterator knows how many times it can iterate, providing access to"},{"DocComment":" that information can be useful. For example, if you want to iterate"},{"DocComment":" backwards, a good start is to know where the end is."},{"DocComment":""},{"DocComment":" When implementing an `ExactSizeIterator`, you must also implement"},{"DocComment":" [`Iterator`]. When doing so, the implementation of [`Iterator::size_hint`]"},{"DocComment":" *must* return the exact size of the iterator."},{"DocComment":""},{"DocComment":" The [`len`] method has a default implementation, so you usually shouldn't"},{"DocComment":" implement it. However, you may be able to provide a more performant"},{"DocComment":" implementation than the default, so overriding it in this case makes sense."},{"DocComment":""},{"DocComment":" Note that this trait is a safe trait and as such does *not* and *cannot*"},{"DocComment":" guarantee that the returned length is correct. This means that `unsafe`"},{"DocComment":" code **must not** rely on the correctness of [`Iterator::size_hint`]. The"},{"DocComment":" unstable and unsafe [`TrustedLen`](super::marker::TrustedLen) trait gives"},{"DocComment":" this additional guarantee."},{"DocComment":""},{"DocComment":" [`len`]: ExactSizeIterator::len"},{"DocComment":""},{"DocComment":" # When *shouldn't* an adapter be `ExactSizeIterator`?"},{"DocComment":""},{"DocComment":" If an adapter makes an iterator *longer*, then it's usually incorrect for"},{"DocComment":" that adapter to implement `ExactSizeIterator`.  The inner exact-sized"},{"DocComment":" iterator might already be `usize::MAX`-long, and thus the length of the"},{"DocComment":" longer adapted iterator would no longer be exactly representable in `usize`."},{"DocComment":""},{"DocComment":" This is why [`Chain<A, B>`](crate::iter::Chain) isn't `ExactSizeIterator`,"},{"DocComment":" even when `A` and `B` are both `ExactSizeIterator`."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Basic usage:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // a finite range knows exactly how many times it will iterate"},{"DocComment":" let five = 0..5;"},{"DocComment":""},{"DocComment":" assert_eq!(5, five.len());"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" In the [module-level docs], we implemented an [`Iterator`], `Counter`."},{"DocComment":" Let's implement `ExactSizeIterator` for it as well:"},{"DocComment":""},{"DocComment":" [module-level docs]: crate::iter"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # struct Counter {"},{"DocComment":" #     count: usize,"},{"DocComment":" # }"},{"DocComment":" # impl Counter {"},{"DocComment":" #     fn new() -> Counter {"},{"DocComment":" #         Counter { count: 0 }"},{"DocComment":" #     }"},{"DocComment":" # }"},{"DocComment":" # impl Iterator for Counter {"},{"DocComment":" #     type Item = usize;"},{"DocComment":" #     fn next(&mut self) -> Option<Self::Item> {"},{"DocComment":" #         self.count += 1;"},{"DocComment":" #         if self.count < 6 {"},{"DocComment":" #             Some(self.count)"},{"DocComment":" #         } else {"},{"DocComment":" #             None"},{"DocComment":" #         }"},{"DocComment":" #     }"},{"DocComment":" # }"},{"DocComment":" impl ExactSizeIterator for Counter {"},{"DocComment":"     // We can easily calculate the remaining number of iterations."},{"DocComment":"     fn len(&self) -> usize {"},{"DocComment":"         5 - self.count"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // And now we can use it!"},{"DocComment":""},{"DocComment":" let mut counter = Counter::new();"},{"DocComment":""},{"DocComment":" assert_eq!(5, counter.len());"},{"DocComment":" let _ = counter.next();"},{"DocComment":" assert_eq!(4, counter.len());"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[{"clause_id":0,"span":{"span":{"file_id":21,"beg":{"line":86,"col":29},"end":{"line":86,"col":37}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[],"provided_methods":[]},{"def_id":15,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ord",0]}],"span":{"span":{"file_id":22,"beg":{"line":946,"col":0},"end":{"line":946,"col":36}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order)."},{"DocComment":""},{"DocComment":" Implementations must be consistent with the [`PartialOrd`] implementation, and ensure `max`,"},{"DocComment":" `min`, and `clamp` are consistent with `cmp`:"},{"DocComment":""},{"DocComment":" - `partial_cmp(a, b) == Some(cmp(a, b))`."},{"DocComment":" - `max(a, b) == max_by(a, b, cmp)` (ensured by the default implementation)."},{"DocComment":" - `min(a, b) == min_by(a, b, cmp)` (ensured by the default implementation)."},{"DocComment":" - For `a.clamp(min, max)`, see the [method docs](#method.clamp) (ensured by the default"},{"DocComment":"   implementation)."},{"DocComment":""},{"DocComment":" Violating these requirements is a logic error. The behavior resulting from a logic error is not"},{"DocComment":" specified, but users of the trait must ensure that such logic errors do *not* result in"},{"DocComment":" undefined behavior. This means that `unsafe` code **must not** rely on the correctness of these"},{"DocComment":" methods."},{"DocComment":""},{"DocComment":" ## Corollaries"},{"DocComment":""},{"DocComment":" From the above and the requirements of `PartialOrd`, it follows that for all `a`, `b` and `c`:"},{"DocComment":""},{"DocComment":" - exactly one of `a < b`, `a == b` or `a > b` is true; and"},{"DocComment":" - `<` is transitive: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and"},{"DocComment":"   `>`."},{"DocComment":""},{"DocComment":" Mathematically speaking, the `<` operator defines a strict [weak order]. In cases where `==`"},{"DocComment":" conforms to mathematical equality, it also defines a strict [total order]."},{"DocComment":""},{"DocComment":" [weak order]: https://en.wikipedia.org/wiki/Weak_ordering"},{"DocComment":" [total order]: https://en.wikipedia.org/wiki/Total_order"},{"DocComment":""},{"DocComment":" ## Derivable"},{"DocComment":""},{"DocComment":" This trait can be used with `#[derive]`."},{"DocComment":""},{"DocComment":" When `derive`d on structs, it will produce a"},{"DocComment":" [lexicographic](https://en.wikipedia.org/wiki/Lexicographic_order) ordering based on the"},{"DocComment":" top-to-bottom declaration order of the struct's members."},{"DocComment":""},{"DocComment":" When `derive`d on enums, variants are ordered primarily by their discriminants. Secondarily,"},{"DocComment":" they are ordered by their fields. By default, the discriminant is smallest for variants at the"},{"DocComment":" top, and largest for variants at the bottom. Here's an example:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(PartialEq, Eq, PartialOrd, Ord)]"},{"DocComment":" enum E {"},{"DocComment":"     Top,"},{"DocComment":"     Bottom,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" assert!(E::Top < E::Bottom);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" However, manually setting the discriminants can override this default behavior:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(PartialEq, Eq, PartialOrd, Ord)]"},{"DocComment":" enum E {"},{"DocComment":"     Top = 2,"},{"DocComment":"     Bottom = 1,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" assert!(E::Bottom < E::Top);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## Lexicographical comparison"},{"DocComment":""},{"DocComment":" Lexicographical comparison is an operation with the following properties:"},{"DocComment":"  - Two sequences are compared element by element."},{"DocComment":"  - The first mismatching element defines which sequence is lexicographically less or greater"},{"DocComment":"    than the other."},{"DocComment":"  - If one sequence is a prefix of another, the shorter sequence is lexicographically less than"},{"DocComment":"    the other."},{"DocComment":"  - If two sequences have equivalent elements and are of the same length, then the sequences are"},{"DocComment":"    lexicographically equal."},{"DocComment":"  - An empty sequence is lexicographically less than any non-empty sequence."},{"DocComment":"  - Two empty sequences are lexicographically equal."},{"DocComment":""},{"DocComment":" ## How can I implement `Ord`?"},{"DocComment":""},{"DocComment":" `Ord` requires that the type also be [`PartialOrd`], [`PartialEq`], and [`Eq`]."},{"DocComment":""},{"DocComment":" Because `Ord` implies a stronger ordering relationship than [`PartialOrd`], and both `Ord` and"},{"DocComment":" [`PartialOrd`] must agree, you must choose how to implement `Ord` **first**. You can choose to"},{"DocComment":" derive it, or implement it manually. If you derive it, you should derive all four traits. If you"},{"DocComment":" implement it manually, you should manually implement all four traits, based on the"},{"DocComment":" implementation of `Ord`."},{"DocComment":""},{"DocComment":" Here's an example where you want to define the `Character` comparison by `health` and"},{"DocComment":" `experience` only, disregarding the field `mana`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" struct Character {"},{"DocComment":"     health: u32,"},{"DocComment":"     experience: u32,"},{"DocComment":"     mana: f32,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Ord for Character {"},{"DocComment":"     fn cmp(&self, other: &Self) -> std::cmp::Ordering {"},{"DocComment":"         self.experience"},{"DocComment":"             .cmp(&other.experience)"},{"DocComment":"             .then(self.health.cmp(&other.health))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialOrd for Character {"},{"DocComment":"     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {"},{"DocComment":"         Some(self.cmp(other))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq for Character {"},{"DocComment":"     fn eq(&self, other: &Self) -> bool {"},{"DocComment":"         self.health == other.health && self.experience == other.experience"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Eq for Character {}"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" If all you need is to `slice::sort` a type by a field value, it can be simpler to use"},{"DocComment":" `slice::sort_by_key`."},{"DocComment":""},{"DocComment":" ## Examples of incorrect `Ord` implementations"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" #[derive(Debug)]"},{"DocComment":" struct Character {"},{"DocComment":"     health: f32,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Ord for Character {"},{"DocComment":"     fn cmp(&self, other: &Self) -> std::cmp::Ordering {"},{"DocComment":"         if self.health < other.health {"},{"DocComment":"             Ordering::Less"},{"DocComment":"         } else if self.health > other.health {"},{"DocComment":"             Ordering::Greater"},{"DocComment":"         } else {"},{"DocComment":"             Ordering::Equal"},{"DocComment":"         }"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialOrd for Character {"},{"DocComment":"     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {"},{"DocComment":"         Some(self.cmp(other))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq for Character {"},{"DocComment":"     fn eq(&self, other: &Self) -> bool {"},{"DocComment":"         self.health == other.health"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Eq for Character {}"},{"DocComment":""},{"DocComment":" let a = Character { health: 4.5 };"},{"DocComment":" let b = Character { health: f32::NAN };"},{"DocComment":""},{"DocComment":" // Mistake: floating-point values do not form a total order and using the built-in comparison"},{"DocComment":" // operands to implement `Ord` irregardless of that reality does not change it. Use"},{"DocComment":" // `f32::total_cmp` if you need a total order for floating-point values."},{"DocComment":""},{"DocComment":" // Reflexivity requirement of `Ord` is not given."},{"DocComment":" assert!(a == a);"},{"DocComment":" assert!(b != b);"},{"DocComment":""},{"DocComment":" // Antisymmetry requirement of `Ord` is not given. Only one of a < c and c < a is allowed to be"},{"DocComment":" // true, not both or neither."},{"DocComment":" assert_eq!((a < b) as u8 + (b < a) as u8, 0);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" #[derive(Debug)]"},{"DocComment":" struct Character {"},{"DocComment":"     health: u32,"},{"DocComment":"     experience: u32,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialOrd for Character {"},{"DocComment":"     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {"},{"DocComment":"         Some(self.cmp(other))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Ord for Character {"},{"DocComment":"     fn cmp(&self, other: &Self) -> std::cmp::Ordering {"},{"DocComment":"         if self.health < 50 {"},{"DocComment":"             self.health.cmp(&other.health)"},{"DocComment":"         } else {"},{"DocComment":"             self.experience.cmp(&other.experience)"},{"DocComment":"         }"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // For performance reasons implementing `PartialEq` this way is not the idiomatic way, but it"},{"DocComment":" // ensures consistent behavior between `PartialEq`, `PartialOrd` and `Ord` in this example."},{"DocComment":" impl PartialEq for Character {"},{"DocComment":"     fn eq(&self, other: &Self) -> bool {"},{"DocComment":"         self.cmp(other) == Ordering::Equal"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Eq for Character {}"},{"DocComment":""},{"DocComment":" let a = Character {"},{"DocComment":"     health: 3,"},{"DocComment":"     experience: 5,"},{"DocComment":" };"},{"DocComment":" let b = Character {"},{"DocComment":"     health: 10,"},{"DocComment":"     experience: 77,"},{"DocComment":" };"},{"DocComment":" let c = Character {"},{"DocComment":"     health: 143,"},{"DocComment":"     experience: 2,"},{"DocComment":" };"},{"DocComment":""},{"DocComment":" // Mistake: The implementation of `Ord` compares different fields depending on the value of"},{"DocComment":" // `self.health`, the resulting order is not total."},{"DocComment":""},{"DocComment":" // Transitivity requirement of `Ord` is not given. If a is smaller than b and b is smaller than"},{"DocComment":" // c, by transitive property a must also be smaller than c."},{"DocComment":" assert!(a < b && b < c && c < a);"},{"DocComment":""},{"DocComment":" // Antisymmetry requirement of `Ord` is not given. Only one of a < c and c < a is allowed to be"},{"DocComment":" // true, not both or neither."},{"DocComment":" assert_eq!((a < c) as u8 + (c < a) as u8, 2);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" The documentation of [`PartialOrd`] contains further examples, for example it's wrong for"},{"DocComment":" [`PartialOrd`] and [`PartialEq`] to disagree."},{"DocComment":""},{"DocComment":" [`cmp`]: Ord::cmp"},{"Unknown":{"path":"doc","args":"alias = \"<\""}},{"Unknown":{"path":"doc","args":"alias = \">\""}},{"Unknown":{"path":"doc","args":"alias = \"<=\""}},{"Unknown":{"path":"doc","args":"alias = \">=\""}},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[{"clause_id":0,"span":{"span":{"file_id":22,"beg":{"line":946,"col":15},"end":{"line":946,"col":17}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"trait_id":22,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":22}}}}}},{"clause_id":1,"span":{"span":{"file_id":22,"beg":{"line":946,"col":20},"end":{"line":946,"col":36}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"trait_id":19,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":19}}}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[["cmp",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":88,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":88}}}},"kind":{"TraitMethod":[15,"cmp"]}}]],"provided_methods":[]},{"def_id":16,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Copy",0]}],"span":{"span":{"file_id":7,"beg":{"line":416,"col":0},"end":{"line":416,"col":21}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Types whose values can be duplicated simply by copying bits."},{"DocComment":""},{"DocComment":" By default, variable bindings have 'move semantics.' In other"},{"DocComment":" words:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(Debug)]"},{"DocComment":" struct Foo;"},{"DocComment":""},{"DocComment":" let x = Foo;"},{"DocComment":""},{"DocComment":" let y = x;"},{"DocComment":""},{"DocComment":" // `x` has moved into `y`, and so cannot be used"},{"DocComment":""},{"DocComment":" // println!(\"{x:?}\"); // error: use of moved value"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" However, if a type implements `Copy`, it instead has 'copy semantics':"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // We can derive a `Copy` implementation. `Clone` is also required, as it's"},{"DocComment":" // a supertrait of `Copy`."},{"DocComment":" #[derive(Debug, Copy, Clone)]"},{"DocComment":" struct Foo;"},{"DocComment":""},{"DocComment":" let x = Foo;"},{"DocComment":""},{"DocComment":" let y = x;"},{"DocComment":""},{"DocComment":" // `y` is a copy of `x`"},{"DocComment":""},{"DocComment":" println!(\"{x:?}\"); // A-OK!"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" It's important to note that in these two examples, the only difference is whether you"},{"DocComment":" are allowed to access `x` after the assignment. Under the hood, both a copy and a move"},{"DocComment":" can result in bits being copied in memory, although this is sometimes optimized away."},{"DocComment":""},{"DocComment":" ## How can I implement `Copy`?"},{"DocComment":""},{"DocComment":" There are two ways to implement `Copy` on your type. The simplest is to use `derive`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(Copy, Clone)]"},{"DocComment":" struct MyStruct;"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" You can also implement `Copy` and `Clone` manually:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" struct MyStruct;"},{"DocComment":""},{"DocComment":" impl Copy for MyStruct { }"},{"DocComment":""},{"DocComment":" impl Clone for MyStruct {"},{"DocComment":"     fn clone(&self) -> MyStruct {"},{"DocComment":"         *self"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" There is a small difference between the two. The `derive` strategy will also place a `Copy`"},{"DocComment":" bound on type parameters:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(Clone)]"},{"DocComment":" struct MyStruct<T>(T);"},{"DocComment":""},{"DocComment":" impl<T: Copy> Copy for MyStruct<T> { }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" This isn't always desired. For example, shared references (`&T`) can be copied regardless of"},{"DocComment":" whether `T` is `Copy`. Likewise, a generic struct containing markers such as [`PhantomData`]"},{"DocComment":" could potentially be duplicated with a bit-wise copy."},{"DocComment":""},{"DocComment":" ## What's the difference between `Copy` and `Clone`?"},{"DocComment":""},{"DocComment":" Copies happen implicitly, for example as part of an assignment `y = x`. The behavior of"},{"DocComment":" `Copy` is not overloadable; it is always a simple bit-wise copy."},{"DocComment":""},{"DocComment":" Cloning is an explicit action, `x.clone()`. The implementation of [`Clone`] can"},{"DocComment":" provide any type-specific behavior necessary to duplicate values safely. For example,"},{"DocComment":" the implementation of [`Clone`] for [`String`] needs to copy the pointed-to string"},{"DocComment":" buffer in the heap. A simple bitwise copy of [`String`] values would merely copy the"},{"DocComment":" pointer, leading to a double free down the line. For this reason, [`String`] is [`Clone`]"},{"DocComment":" but not `Copy`."},{"DocComment":""},{"DocComment":" [`Clone`] is a supertrait of `Copy`, so everything which is `Copy` must also implement"},{"DocComment":" [`Clone`]. If a type is `Copy` then its [`Clone`] implementation only needs to return `*self`"},{"DocComment":" (see the example above)."},{"DocComment":""},{"DocComment":" ## When can my type be `Copy`?"},{"DocComment":""},{"DocComment":" A type can implement `Copy` if all of its components implement `Copy`. For example, this"},{"DocComment":" struct can be `Copy`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #[allow(dead_code)]"},{"DocComment":" #[derive(Copy, Clone)]"},{"DocComment":" struct Point {"},{"DocComment":"    x: i32,"},{"DocComment":"    y: i32,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" A struct can be `Copy`, and [`i32`] is `Copy`, therefore `Point` is eligible to be `Copy`."},{"DocComment":" By contrast, consider"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #![allow(dead_code)]"},{"DocComment":" # struct Point;"},{"DocComment":" struct PointList {"},{"DocComment":"     points: Vec<Point>,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" The struct `PointList` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`. If we"},{"DocComment":" attempt to derive a `Copy` implementation, we'll get an error:"},{"DocComment":""},{"DocComment":" ```text"},{"DocComment":" the trait `Copy` cannot be implemented for this type; field `points` does not implement `Copy`"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Shared references (`&T`) are also `Copy`, so a type can be `Copy`, even when it holds"},{"DocComment":" shared references of types `T` that are *not* `Copy`. Consider the following struct,"},{"DocComment":" which can implement `Copy`, because it only holds a *shared reference* to our non-`Copy`"},{"DocComment":" type `PointList` from above:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #![allow(dead_code)]"},{"DocComment":" # struct PointList;"},{"DocComment":" #[derive(Copy, Clone)]"},{"DocComment":" struct PointListWrapper<'a> {"},{"DocComment":"     point_list_ref: &'a PointList,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## When *can't* my type be `Copy`?"},{"DocComment":""},{"DocComment":" Some types can't be copied safely. For example, copying `&mut T` would create an aliased"},{"DocComment":" mutable reference. Copying [`String`] would duplicate responsibility for managing the"},{"DocComment":" [`String`]'s buffer, leading to a double free."},{"DocComment":""},{"DocComment":" Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's"},{"DocComment":" managing some resource besides its own [`size_of::<T>`] bytes."},{"DocComment":""},{"DocComment":" If you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get"},{"DocComment":" the error [E0204]."},{"DocComment":""},{"DocComment":" [E0204]: ../../error_codes/E0204.html"},{"DocComment":""},{"DocComment":" ## When *should* my type be `Copy`?"},{"DocComment":""},{"DocComment":" Generally speaking, if your type _can_ implement `Copy`, it should. Keep in mind, though,"},{"DocComment":" that implementing `Copy` is part of the public API of your type. If the type might become"},{"DocComment":" non-`Copy` in the future, it could be prudent to omit the `Copy` implementation now, to"},{"DocComment":" avoid a breaking API change."},{"DocComment":""},{"DocComment":" ## Additional implementors"},{"DocComment":""},{"DocComment":" In addition to the [implementors listed below][impls],"},{"DocComment":" the following types also implement `Copy`:"},{"DocComment":""},{"DocComment":" * Function item types (i.e., the distinct types defined for each function)"},{"DocComment":" * Function pointer types (e.g., `fn() -> i32`)"},{"DocComment":" * Closure types, if they capture no value from the environment"},{"DocComment":"   or if all such captured values implement `Copy` themselves."},{"DocComment":"   Note that variables captured by shared reference always implement `Copy`"},{"DocComment":"   (even if the referent doesn't),"},{"DocComment":"   while variables captured by mutable reference never implement `Copy`."},{"DocComment":""},{"DocComment":" [`Vec<T>`]: ../../std/vec/struct.Vec.html"},{"DocComment":" [`String`]: ../../std/string/struct.String.html"},{"DocComment":" [`size_of::<T>`]: crate::mem::size_of"},{"DocComment":" [impls]: #implementors"},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[{"clause_id":0,"span":{"span":{"file_id":7,"beg":{"line":416,"col":16},"end":{"line":416,"col":21}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"trait_id":7,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":7}}}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[],"provided_methods":[]},{"def_id":17,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Sum",0]}],"span":{"span":{"file_id":23,"beg":{"line":17,"col":0},"end":{"line":17,"col":30}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Trait to represent types that can be created by summing up an iterator."},{"DocComment":""},{"DocComment":" This trait is used to implement [`Iterator::sum()`]. Types which implement"},{"DocComment":" this trait can be generated by using the [`sum()`] method on an iterator."},{"DocComment":" Like [`FromIterator`], this trait should rarely be called directly."},{"DocComment":""},{"DocComment":" [`sum()`]: Iterator::sum"},{"DocComment":" [`FromIterator`]: iter::FromIterator"},{"Unknown":{"path":"rustc_on_unimplemented","args":"message =\n\"a value of type `{Self}` cannot be made by summing an iterator over elements of type `{A}`\",\nlabel =\n\"value of type `{Self}` cannot be made by summing a `std::iter::Iterator<Item={A}>`\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[["sum",{"params":{"regions":[],"types":[{"index":0,"name":"I"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":23,"beg":{"line":21,"col":14},"end":{"line":21,"col":32}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[{"regions":[],"skip_binder":{"trait_ref":{"kind":{"Clause":{"Bound":[1,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[2,0]}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},"type_name":"Item","ty":{"TypeVar":{"Free":1}}}}]},"skip_binder":{"id":103,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Bound":[0,0]}}],"const_generics":[],"trait_refs":[null,{"kind":{"Clause":{"Bound":[0,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"target":{"Item":{"Fun":103}}}},"kind":{"TraitMethod":[17,"sum"]}}]],"provided_methods":[]},{"def_id":18,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Product",0]}],"span":{"span":{"file_id":23,"beg":{"line":38,"col":0},"end":{"line":38,"col":34}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Trait to represent types that can be created by multiplying elements of an"},{"DocComment":" iterator."},{"DocComment":""},{"DocComment":" This trait is used to implement [`Iterator::product()`]. Types which implement"},{"DocComment":" this trait can be generated by using the [`product()`] method on an iterator."},{"DocComment":" Like [`FromIterator`], this trait should rarely be called directly."},{"DocComment":""},{"DocComment":" [`product()`]: Iterator::product"},{"DocComment":" [`FromIterator`]: iter::FromIterator"},{"Unknown":{"path":"rustc_on_unimplemented","args":"message =\n\"a value of type `{Self}` cannot be made by multiplying all elements of type `{A}` from an iterator\",\nlabel =\n\"value of type `{Self}` cannot be made by multiplying all elements from a `std::iter::Iterator<Item={A}>`\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[["product",{"params":{"regions":[],"types":[{"index":0,"name":"I"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":23,"beg":{"line":42,"col":18},"end":{"line":42,"col":36}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[{"regions":[],"skip_binder":{"trait_ref":{"kind":{"Clause":{"Bound":[1,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[2,0]}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},"type_name":"Item","ty":{"TypeVar":{"Free":1}}}}]},"skip_binder":{"id":104,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Bound":[0,0]}}],"const_generics":[],"trait_refs":[null,{"kind":{"Clause":{"Bound":[0,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"target":{"Item":{"Fun":104}}}},"kind":{"TraitMethod":[18,"product"]}}]],"provided_methods":[]},{"def_id":19,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]}],"span":{"span":{"file_id":22,"beg":{"line":1293,"col":0},"end":{"line":1293,"col":56}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Trait for types that form a [partial order](https://en.wikipedia.org/wiki/Partial_order)."},{"DocComment":""},{"DocComment":" The `lt`, `le`, `gt`, and `ge` methods of this trait can be called using the `<`, `<=`, `>`, and"},{"DocComment":" `>=` operators, respectively."},{"DocComment":""},{"DocComment":" This trait should **only** contain the comparison logic for a type **if one plans on only"},{"DocComment":" implementing `PartialOrd` but not [`Ord`]**. Otherwise the comparison logic should be in [`Ord`]"},{"DocComment":" and this trait implemented with `Some(self.cmp(other))`."},{"DocComment":""},{"DocComment":" The methods of this trait must be consistent with each other and with those of [`PartialEq`]."},{"DocComment":" The following conditions must hold:"},{"DocComment":""},{"DocComment":" 1. `a == b` if and only if `partial_cmp(a, b) == Some(Equal)`."},{"DocComment":" 2. `a < b` if and only if `partial_cmp(a, b) == Some(Less)`"},{"DocComment":" 3. `a > b` if and only if `partial_cmp(a, b) == Some(Greater)`"},{"DocComment":" 4. `a <= b` if and only if `a < b || a == b`"},{"DocComment":" 5. `a >= b` if and only if `a > b || a == b`"},{"DocComment":" 6. `a != b` if and only if `!(a == b)`."},{"DocComment":""},{"DocComment":" Conditions 25 above are ensured by the default implementation. Condition 6 is already ensured"},{"DocComment":" by [`PartialEq`]."},{"DocComment":""},{"DocComment":" If [`Ord`] is also implemented for `Self` and `Rhs`, it must also be consistent with"},{"DocComment":" `partial_cmp` (see the documentation of that trait for the exact requirements). It's easy to"},{"DocComment":" accidentally make them disagree by deriving some of the traits and manually implementing others."},{"DocComment":""},{"DocComment":" The comparison relations must satisfy the following conditions (for all `a`, `b`, `c` of type"},{"DocComment":" `A`, `B`, `C`):"},{"DocComment":""},{"DocComment":" - **Transitivity**: if `A: PartialOrd<B>` and `B: PartialOrd<C>` and `A: PartialOrd<C>`, then `a"},{"DocComment":"   < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`. This must also"},{"DocComment":"   work for longer chains, such as when `A: PartialOrd<B>`, `B: PartialOrd<C>`, `C:"},{"DocComment":"   PartialOrd<D>`, and `A: PartialOrd<D>` all exist."},{"DocComment":" - **Duality**: if `A: PartialOrd<B>` and `B: PartialOrd<A>`, then `a < b` if and only if `b >"},{"DocComment":"   a`."},{"DocComment":""},{"DocComment":" Note that the `B: PartialOrd<A>` (dual) and `A: PartialOrd<C>` (transitive) impls are not forced"},{"DocComment":" to exist, but these requirements apply whenever they do exist."},{"DocComment":""},{"DocComment":" Violating these requirements is a logic error. The behavior resulting from a logic error is not"},{"DocComment":" specified, but users of the trait must ensure that such logic errors do *not* result in"},{"DocComment":" undefined behavior. This means that `unsafe` code **must not** rely on the correctness of these"},{"DocComment":" methods."},{"DocComment":""},{"DocComment":" ## Cross-crate considerations"},{"DocComment":""},{"DocComment":" Upholding the requirements stated above can become tricky when one crate implements `PartialOrd`"},{"DocComment":" for a type of another crate (i.e., to allow comparing one of its own types with a type from the"},{"DocComment":" standard library). The recommendation is to never implement this trait for a foreign type. In"},{"DocComment":" other words, such a crate should do `impl PartialOrd<ForeignType> for LocalType`, but it should"},{"DocComment":" *not* do `impl PartialOrd<LocalType> for ForeignType`."},{"DocComment":""},{"DocComment":" This avoids the problem of transitive chains that criss-cross crate boundaries: for all local"},{"DocComment":" types `T`, you may assume that no other crate will add `impl`s that allow comparing `T < U`. In"},{"DocComment":" other words, if other crates add `impl`s that allow building longer transitive chains `U1 < ..."},{"DocComment":" < T < V1 < ...`, then all the types that appear to the right of `T` must be types that the crate"},{"DocComment":" defining `T` already knows about. This rules out transitive chains where downstream crates can"},{"DocComment":" add new `impl`s that \"stitch together\" comparisons of foreign types in ways that violate"},{"DocComment":" transitivity."},{"DocComment":""},{"DocComment":" Not having such foreign `impl`s also avoids forward compatibility issues where one crate adding"},{"DocComment":" more `PartialOrd` implementations can cause build failures in downstream crates."},{"DocComment":""},{"DocComment":" ## Corollaries"},{"DocComment":""},{"DocComment":" The following corollaries follow from the above requirements:"},{"DocComment":""},{"DocComment":" - irreflexivity of `<` and `>`: `!(a < a)`, `!(a > a)`"},{"DocComment":" - transitivity of `>`: if `a > b` and `b > c` then `a > c`"},{"DocComment":" - duality of `partial_cmp`: `partial_cmp(a, b) == partial_cmp(b, a).map(Ordering::reverse)`"},{"DocComment":""},{"DocComment":" ## Strict and non-strict partial orders"},{"DocComment":""},{"DocComment":" The `<` and `>` operators behave according to a *strict* partial order. However, `<=` and `>=`"},{"DocComment":" do **not** behave according to a *non-strict* partial order. That is because mathematically, a"},{"DocComment":" non-strict partial order would require reflexivity, i.e. `a <= a` would need to be true for"},{"DocComment":" every `a`. This isn't always the case for types that implement `PartialOrd`, for example:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let a = f64::sqrt(-1.0);"},{"DocComment":" assert_eq!(a <= a, false);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## Derivable"},{"DocComment":""},{"DocComment":" This trait can be used with `#[derive]`."},{"DocComment":""},{"DocComment":" When `derive`d on structs, it will produce a"},{"DocComment":" [lexicographic](https://en.wikipedia.org/wiki/Lexicographic_order) ordering based on the"},{"DocComment":" top-to-bottom declaration order of the struct's members."},{"DocComment":""},{"DocComment":" When `derive`d on enums, variants are primarily ordered by their discriminants. Secondarily,"},{"DocComment":" they are ordered by their fields. By default, the discriminant is smallest for variants at the"},{"DocComment":" top, and largest for variants at the bottom. Here's an example:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(PartialEq, PartialOrd)]"},{"DocComment":" enum E {"},{"DocComment":"     Top,"},{"DocComment":"     Bottom,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" assert!(E::Top < E::Bottom);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" However, manually setting the discriminants can override this default behavior:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(PartialEq, PartialOrd)]"},{"DocComment":" enum E {"},{"DocComment":"     Top = 2,"},{"DocComment":"     Bottom = 1,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" assert!(E::Bottom < E::Top);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## How can I implement `PartialOrd`?"},{"DocComment":""},{"DocComment":" `PartialOrd` only requires implementation of the [`partial_cmp`] method, with the others"},{"DocComment":" generated from default implementations."},{"DocComment":""},{"DocComment":" However it remains possible to implement the others separately for types which do not have a"},{"DocComment":" total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 == false`"},{"DocComment":" (cf. IEEE 754-2008 section 5.11)."},{"DocComment":""},{"DocComment":" `PartialOrd` requires your type to be [`PartialEq`]."},{"DocComment":""},{"DocComment":" If your type is [`Ord`], you can implement [`partial_cmp`] by using [`cmp`]:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" struct Person {"},{"DocComment":"     id: u32,"},{"DocComment":"     name: String,"},{"DocComment":"     height: u32,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialOrd for Person {"},{"DocComment":"     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {"},{"DocComment":"         Some(self.cmp(other))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Ord for Person {"},{"DocComment":"     fn cmp(&self, other: &Self) -> Ordering {"},{"DocComment":"         self.height.cmp(&other.height)"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq for Person {"},{"DocComment":"     fn eq(&self, other: &Self) -> bool {"},{"DocComment":"         self.height == other.height"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Eq for Person {}"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" You may also find it useful to use [`partial_cmp`] on your type's fields. Here is an example of"},{"DocComment":" `Person` types who have a floating-point `height` field that is the only field to be used for"},{"DocComment":" sorting:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" struct Person {"},{"DocComment":"     id: u32,"},{"DocComment":"     name: String,"},{"DocComment":"     height: f64,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialOrd for Person {"},{"DocComment":"     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {"},{"DocComment":"         self.height.partial_cmp(&other.height)"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq for Person {"},{"DocComment":"     fn eq(&self, other: &Self) -> bool {"},{"DocComment":"         self.height == other.height"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## Examples of incorrect `PartialOrd` implementations"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" #[derive(PartialEq, Debug)]"},{"DocComment":" struct Character {"},{"DocComment":"     health: u32,"},{"DocComment":"     experience: u32,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialOrd for Character {"},{"DocComment":"     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {"},{"DocComment":"         Some(self.health.cmp(&other.health))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let a = Character {"},{"DocComment":"     health: 10,"},{"DocComment":"     experience: 5,"},{"DocComment":" };"},{"DocComment":" let b = Character {"},{"DocComment":"     health: 10,"},{"DocComment":"     experience: 77,"},{"DocComment":" };"},{"DocComment":""},{"DocComment":" // Mistake: `PartialEq` and `PartialOrd` disagree with each other."},{"DocComment":""},{"DocComment":" assert_eq!(a.partial_cmp(&b).unwrap(), Ordering::Equal); // a == b according to `PartialOrd`."},{"DocComment":" assert_ne!(a, b); // a != b according to `PartialEq`."},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let x: u32 = 0;"},{"DocComment":" let y: u32 = 1;"},{"DocComment":""},{"DocComment":" assert_eq!(x < y, true);"},{"DocComment":" assert_eq!(x.lt(&y), true);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`partial_cmp`]: PartialOrd::partial_cmp"},{"DocComment":" [`cmp`]: Ord::cmp"},{"Unknown":{"path":"doc","args":"alias = \">\""}},{"Unknown":{"path":"doc","args":"alias = \"<\""}},{"Unknown":{"path":"doc","args":"alias = \"<=\""}},{"Unknown":{"path":"doc","args":"alias = \">=\""}},{"Unknown":{"path":"rustc_on_unimplemented","args":"message = \"can't compare `{Self}` with `{Rhs}`\", label =\n\"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\",\nappend_const_msg"}},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Rhs"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[{"clause_id":0,"span":{"span":{"file_id":22,"beg":{"line":1293,"col":42},"end":{"line":1293,"col":56}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"trait_id":20,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":20}}}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[["partial_cmp",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":93,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}}],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":93}}}},"kind":{"TraitMethod":[19,"partial_cmp"]}}]],"provided_methods":[]},{"def_id":20,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialEq",0]}],"span":{"span":{"file_id":22,"beg":{"line":248,"col":0},"end":{"line":248,"col":39}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Trait for comparisons using the equality operator."},{"DocComment":""},{"DocComment":" Implementing this trait for types provides the `==` and `!=` operators for"},{"DocComment":" those types."},{"DocComment":""},{"DocComment":" `x.eq(y)` can also be written `x == y`, and `x.ne(y)` can be written `x != y`."},{"DocComment":" We use the easier-to-read infix notation in the remainder of this documentation."},{"DocComment":""},{"DocComment":" This trait allows for comparisons using the equality operator, for types"},{"DocComment":" that do not have a full equivalence relation. For example, in floating point"},{"DocComment":" numbers `NaN != NaN`, so floating point types implement `PartialEq` but not"},{"DocComment":" [`trait@Eq`]. Formally speaking, when `Rhs == Self`, this trait corresponds"},{"DocComment":" to a [partial equivalence relation]."},{"DocComment":""},{"DocComment":" [partial equivalence relation]: https://en.wikipedia.org/wiki/Partial_equivalence_relation"},{"DocComment":""},{"DocComment":" Implementations must ensure that `eq` and `ne` are consistent with each other:"},{"DocComment":""},{"DocComment":" - `a != b` if and only if `!(a == b)`."},{"DocComment":""},{"DocComment":" The default implementation of `ne` provides this consistency and is almost"},{"DocComment":" always sufficient. It should not be overridden without very good reason."},{"DocComment":""},{"DocComment":" If [`PartialOrd`] or [`Ord`] are also implemented for `Self` and `Rhs`, their methods must also"},{"DocComment":" be consistent with `PartialEq` (see the documentation of those traits for the exact"},{"DocComment":" requirements). It's easy to accidentally make them disagree by deriving some of the traits and"},{"DocComment":" manually implementing others."},{"DocComment":""},{"DocComment":" The equality relation `==` must satisfy the following conditions"},{"DocComment":" (for all `a`, `b`, `c` of type `A`, `B`, `C`):"},{"DocComment":""},{"DocComment":" - **Symmetry**: if `A: PartialEq<B>` and `B: PartialEq<A>`, then **`a == b`"},{"DocComment":"   implies `b == a`**; and"},{"DocComment":""},{"DocComment":" - **Transitivity**: if `A: PartialEq<B>` and `B: PartialEq<C>` and `A:"},{"DocComment":"   PartialEq<C>`, then **`a == b` and `b == c` implies `a == c`**."},{"DocComment":"   This must also work for longer chains, such as when `A: PartialEq<B>`, `B: PartialEq<C>`,"},{"DocComment":"   `C: PartialEq<D>`, and `A: PartialEq<D>` all exist."},{"DocComment":""},{"DocComment":" Note that the `B: PartialEq<A>` (symmetric) and `A: PartialEq<C>`"},{"DocComment":" (transitive) impls are not forced to exist, but these requirements apply"},{"DocComment":" whenever they do exist."},{"DocComment":""},{"DocComment":" Violating these requirements is a logic error. The behavior resulting from a logic error is not"},{"DocComment":" specified, but users of the trait must ensure that such logic errors do *not* result in"},{"DocComment":" undefined behavior. This means that `unsafe` code **must not** rely on the correctness of these"},{"DocComment":" methods."},{"DocComment":""},{"DocComment":" ## Cross-crate considerations"},{"DocComment":""},{"DocComment":" Upholding the requirements stated above can become tricky when one crate implements `PartialEq`"},{"DocComment":" for a type of another crate (i.e., to allow comparing one of its own types with a type from the"},{"DocComment":" standard library). The recommendation is to never implement this trait for a foreign type. In"},{"DocComment":" other words, such a crate should do `impl PartialEq<ForeignType> for LocalType`, but it should"},{"DocComment":" *not* do `impl PartialEq<LocalType> for ForeignType`."},{"DocComment":""},{"DocComment":" This avoids the problem of transitive chains that criss-cross crate boundaries: for all local"},{"DocComment":" types `T`, you may assume that no other crate will add `impl`s that allow comparing `T == U`. In"},{"DocComment":" other words, if other crates add `impl`s that allow building longer transitive chains `U1 == ..."},{"DocComment":" == T == V1 == ...`, then all the types that appear to the right of `T` must be types that the"},{"DocComment":" crate defining `T` already knows about. This rules out transitive chains where downstream crates"},{"DocComment":" can add new `impl`s that \"stitch together\" comparisons of foreign types in ways that violate"},{"DocComment":" transitivity."},{"DocComment":""},{"DocComment":" Not having such foreign `impl`s also avoids forward compatibility issues where one crate adding"},{"DocComment":" more `PartialEq` implementations can cause build failures in downstream crates."},{"DocComment":""},{"DocComment":" ## Derivable"},{"DocComment":""},{"DocComment":" This trait can be used with `#[derive]`. When `derive`d on structs, two"},{"DocComment":" instances are equal if all fields are equal, and not equal if any fields"},{"DocComment":" are not equal. When `derive`d on enums, two instances are equal if they"},{"DocComment":" are the same variant and all fields are equal."},{"DocComment":""},{"DocComment":" ## How can I implement `PartialEq`?"},{"DocComment":""},{"DocComment":" An example implementation for a domain in which two books are considered"},{"DocComment":" the same book if their ISBN matches, even if the formats differ:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" enum BookFormat {"},{"DocComment":"     Paperback,"},{"DocComment":"     Hardback,"},{"DocComment":"     Ebook,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" struct Book {"},{"DocComment":"     isbn: i32,"},{"DocComment":"     format: BookFormat,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq for Book {"},{"DocComment":"     fn eq(&self, other: &Self) -> bool {"},{"DocComment":"         self.isbn == other.isbn"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let b1 = Book { isbn: 3, format: BookFormat::Paperback };"},{"DocComment":" let b2 = Book { isbn: 3, format: BookFormat::Ebook };"},{"DocComment":" let b3 = Book { isbn: 10, format: BookFormat::Paperback };"},{"DocComment":""},{"DocComment":" assert!(b1 == b2);"},{"DocComment":" assert!(b1 != b3);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## How can I compare two different types?"},{"DocComment":""},{"DocComment":" The type you can compare with is controlled by `PartialEq`'s type parameter."},{"DocComment":" For example, let's tweak our previous code a bit:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // The derive implements <BookFormat> == <BookFormat> comparisons"},{"DocComment":" #[derive(PartialEq)]"},{"DocComment":" enum BookFormat {"},{"DocComment":"     Paperback,"},{"DocComment":"     Hardback,"},{"DocComment":"     Ebook,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" struct Book {"},{"DocComment":"     isbn: i32,"},{"DocComment":"     format: BookFormat,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // Implement <Book> == <BookFormat> comparisons"},{"DocComment":" impl PartialEq<BookFormat> for Book {"},{"DocComment":"     fn eq(&self, other: &BookFormat) -> bool {"},{"DocComment":"         self.format == *other"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // Implement <BookFormat> == <Book> comparisons"},{"DocComment":" impl PartialEq<Book> for BookFormat {"},{"DocComment":"     fn eq(&self, other: &Book) -> bool {"},{"DocComment":"         *self == other.format"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let b1 = Book { isbn: 3, format: BookFormat::Paperback };"},{"DocComment":""},{"DocComment":" assert!(b1 == BookFormat::Paperback);"},{"DocComment":" assert!(BookFormat::Ebook != b1);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" By changing `impl PartialEq for Book` to `impl PartialEq<BookFormat> for Book`,"},{"DocComment":" we allow `BookFormat`s to be compared with `Book`s."},{"DocComment":""},{"DocComment":" A comparison like the one above, which ignores some fields of the struct,"},{"DocComment":" can be dangerous. It can easily lead to an unintended violation of the"},{"DocComment":" requirements for a partial equivalence relation. For example, if we kept"},{"DocComment":" the above implementation of `PartialEq<Book>` for `BookFormat` and added an"},{"DocComment":" implementation of `PartialEq<Book>` for `Book` (either via a `#[derive]` or"},{"DocComment":" via the manual implementation from the first example) then the result would"},{"DocComment":" violate transitivity:"},{"DocComment":""},{"DocComment":" ```should_panic"},{"DocComment":" #[derive(PartialEq)]"},{"DocComment":" enum BookFormat {"},{"DocComment":"     Paperback,"},{"DocComment":"     Hardback,"},{"DocComment":"     Ebook,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" #[derive(PartialEq)]"},{"DocComment":" struct Book {"},{"DocComment":"     isbn: i32,"},{"DocComment":"     format: BookFormat,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq<BookFormat> for Book {"},{"DocComment":"     fn eq(&self, other: &BookFormat) -> bool {"},{"DocComment":"         self.format == *other"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq<Book> for BookFormat {"},{"DocComment":"     fn eq(&self, other: &Book) -> bool {"},{"DocComment":"         *self == other.format"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" fn main() {"},{"DocComment":"     let b1 = Book { isbn: 1, format: BookFormat::Paperback };"},{"DocComment":"     let b2 = Book { isbn: 2, format: BookFormat::Paperback };"},{"DocComment":""},{"DocComment":"     assert!(b1 == BookFormat::Paperback);"},{"DocComment":"     assert!(BookFormat::Paperback == b2);"},{"DocComment":""},{"DocComment":"     // The following should hold by transitivity but doesn't."},{"DocComment":"     assert!(b1 == b2); // <-- PANICS"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let x: u32 = 0;"},{"DocComment":" let y: u32 = 1;"},{"DocComment":""},{"DocComment":" assert_eq!(x == y, false);"},{"DocComment":" assert_eq!(x.eq(&y), false);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`eq`]: PartialEq::eq"},{"DocComment":" [`ne`]: PartialEq::ne"},{"Unknown":{"path":"doc","args":"alias = \"==\""}},{"Unknown":{"path":"doc","args":"alias = \"!=\""}},{"Unknown":{"path":"rustc_on_unimplemented","args":"message = \"can't compare `{Self}` with `{Rhs}`\", label =\n\"no implementation for `{Self} == {Rhs}`\", append_const_msg"}},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Rhs"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[["eq",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":86,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}}],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":86}}}},"kind":{"TraitMethod":[20,"eq"]}}]],"provided_methods":[]},{"def_id":21,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["adapters",0]},{"Ident":["zip",0]},{"Ident":["TrustedRandomAccessNoCoerce",0]}],"span":{"span":{"file_id":24,"beg":{"line":593,"col":0},"end":{"line":593,"col":51}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Like [`TrustedRandomAccess`] but without any of the requirements / guarantees around"},{"DocComment":" coercions to subtypes after `__iterator_get_unchecked` (they arent allowed here!), and"},{"DocComment":" without the requirement that subtypes / supertypes implement `TrustedRandomAccessNoCoerce`."},{"DocComment":""},{"DocComment":" This trait was created in PR #85874 to fix soundness issue #85873 without performance regressions."},{"DocComment":" It is subject to change as we might want to build a more generally useful (for performance"},{"DocComment":" optimizations) and more sophisticated trait or trait hierarchy that replaces or extends"},{"DocComment":" [`TrustedRandomAccess`] and `TrustedRandomAccessNoCoerce`."},{"Unknown":{"path":"doc","args":"hidden"}},{"Unknown":{"path":"unstable","args":"feature = \"trusted_random_access\", issue = \"none\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null],"consts":[["MAY_HAVE_SIDE_EFFECT",{"Literal":"Bool"}]],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[],"provided_methods":[]},{"def_id":22,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Eq",0]}],"span":{"span":{"file_id":22,"beg":{"line":334,"col":0},"end":{"line":334,"col":29}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Trait for comparisons corresponding to [equivalence relations]("},{"DocComment":" https://en.wikipedia.org/wiki/Equivalence_relation)."},{"DocComment":""},{"DocComment":" The primary difference to [`PartialEq`] is the additional requirement for reflexivity. A type"},{"DocComment":" that implements [`PartialEq`] guarantees that for all `a`, `b` and `c`:"},{"DocComment":""},{"DocComment":" - symmetric: `a == b` implies `b == a` and `a != b` implies `!(a == b)`"},{"DocComment":" - transitive: `a == b` and `b == c` implies `a == c`"},{"DocComment":""},{"DocComment":" `Eq`, which builds on top of [`PartialEq`] also implies:"},{"DocComment":""},{"DocComment":" - reflexive: `a == a`"},{"DocComment":""},{"DocComment":" This property cannot be checked by the compiler, and therefore `Eq` is a trait without methods."},{"DocComment":""},{"DocComment":" Violating this property is a logic error. The behavior resulting from a logic error is not"},{"DocComment":" specified, but users of the trait must ensure that such logic errors do *not* result in"},{"DocComment":" undefined behavior. This means that `unsafe` code **must not** rely on the correctness of these"},{"DocComment":" methods."},{"DocComment":""},{"DocComment":" Floating point types such as [`f32`] and [`f64`] implement only [`PartialEq`] but *not* `Eq`"},{"DocComment":" because `NaN` != `NaN`."},{"DocComment":""},{"DocComment":" ## Derivable"},{"DocComment":""},{"DocComment":" This trait can be used with `#[derive]`. When `derive`d, because `Eq` has no extra methods, it"},{"DocComment":" is only informing the compiler that this is an equivalence relation rather than a partial"},{"DocComment":" equivalence relation. Note that the `derive` strategy requires all fields are `Eq`, which isn't"},{"DocComment":" always desired."},{"DocComment":""},{"DocComment":" ## How can I implement `Eq`?"},{"DocComment":""},{"DocComment":" If you cannot use the `derive` strategy, specify that your type implements `Eq`, which has no"},{"DocComment":" extra methods:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" enum BookFormat {"},{"DocComment":"     Paperback,"},{"DocComment":"     Hardback,"},{"DocComment":"     Ebook,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" struct Book {"},{"DocComment":"     isbn: i32,"},{"DocComment":"     format: BookFormat,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq for Book {"},{"DocComment":"     fn eq(&self, other: &Self) -> bool {"},{"DocComment":"         self.isbn == other.isbn"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Eq for Book {}"},{"DocComment":" ```"},{"Unknown":{"path":"doc","args":"alias = \"==\""}},{"Unknown":{"path":"doc","args":"alias = \"!=\""}},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[{"clause_id":0,"span":{"span":{"file_id":22,"beg":{"line":334,"col":14},"end":{"line":334,"col":29}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"trait_id":20,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":20}}}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[],"provided_methods":[]},{"def_id":23,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["FromResidual",0]}],"span":{"span":{"file_id":18,"beg":{"line":307,"col":0},"end":{"line":307,"col":51}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Used to specify which residuals can be converted into which [`crate::ops::Try`] types."},{"DocComment":""},{"DocComment":" Every `Try` type needs to be recreatable from its own associated"},{"DocComment":" `Residual` type, but can also have additional `FromResidual` implementations"},{"DocComment":" to support interconversion with other `Try` types."},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(all(from_desugaring = \"QuestionMark\", _Self = \"core::result::Result<T, E>\",\nR = \"core::option::Option<core::convert::Infallible>\",), message =\n\"the `?` operator can only be used on `Result`s, not `Option`s, \\\n            in {ItemContext} that returns `Result`\",\nlabel = \"use `.ok_or(...)?` to provide an error compatible with `{Self}`\",\nparent_label = \"this function returns a `Result`\"),\non(all(from_desugaring = \"QuestionMark\", _Self =\n\"core::result::Result<T, E>\",), message =\n\"the `?` operator can only be used on `Result`s \\\n            in {ItemContext} that returns `Result`\",\nlabel = \"this `?` produces `{R}`, which is incompatible with `{Self}`\",\nparent_label = \"this function returns a `Result`\"),\non(all(from_desugaring = \"QuestionMark\", _Self = \"core::option::Option<T>\", R\n= \"core::result::Result<T, E>\",), message =\n\"the `?` operator can only be used on `Option`s, not `Result`s, \\\n            in {ItemContext} that returns `Option`\",\nlabel = \"use `.ok()?` if you want to discard the `{R}` error information\",\nparent_label = \"this function returns an `Option`\"),\non(all(from_desugaring = \"QuestionMark\", _Self = \"core::option::Option<T>\",),\nmessage =\n\"the `?` operator can only be used on `Option`s \\\n            in {ItemContext} that returns `Option`\",\nlabel = \"this `?` produces `{R}`, which is incompatible with `{Self}`\",\nparent_label = \"this function returns an `Option`\"),\non(all(from_desugaring = \"QuestionMark\", _Self =\n\"core::ops::control_flow::ControlFlow<B, C>\", R =\n\"core::ops::control_flow::ControlFlow<B, C>\",), message =\n\"the `?` operator in {ItemContext} that returns `ControlFlow<B, _>` \\\n            can only be used on other `ControlFlow<B, _>`s (with the same Break type)\",\nlabel = \"this `?` produces `{R}`, which is incompatible with `{Self}`\",\nparent_label = \"this function returns a `ControlFlow`\", note =\n\"unlike `Result`, there's no `From`-conversion performed for `ControlFlow`\"),\non(all(from_desugaring = \"QuestionMark\", _Self =\n\"core::ops::control_flow::ControlFlow<B, C>\",), message =\n\"the `?` operator can only be used on `ControlFlow`s \\\n            in {ItemContext} that returns `ControlFlow`\",\nlabel = \"this `?` produces `{R}`, which is incompatible with `{Self}`\",\nparent_label = \"this function returns a `ControlFlow`\",),\non(all(from_desugaring = \"QuestionMark\"), message =\n\"the `?` operator can only be used in {ItemContext} \\\n                    that returns `Result` or `Option` \\\n                    (or another type that implements `{FromResidual}`)\",\nlabel = \"cannot use the `?` operator in {ItemContext} that returns `{Self}`\",\nparent_label =\n\"this function should return `Result` or `Option` to accept `?`\"),"}},{"Unknown":{"path":"rustc_diagnostic_item","args":null}},{"Unknown":{"path":"unstable","args":"feature = \"try_trait_v2\", issue = \"84277\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"R"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[["from_residual",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":101,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":101}}}},"kind":{"TraitMethod":[23,"from_residual"]}}]],"provided_methods":[]}],"trait_impls":[{"def_id":0,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":[{"Trait":0},182]}],"span":{"span":{"file_id":10,"beg":{"line":152,"col":8},"end":{"line":152,"col":45}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign"},"impl_trait":{"trait_id":1,"generics":{"regions":[],"types":[{"Adt":[{"Adt":1},{"regions":[{"Var":{"Free":0}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Type":1}}}]}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}},"generics":{"regions":[{"index":0,"name":"'a"}],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[null],"consts":[],"types":[["Item",{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]}]],"type_clauses":[],"required_methods":[["next",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":121,"generics":{"regions":[{"Var":{"Free":0}},{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null],"target":{"Item":{"Fun":121}}}},"kind":{"TraitMethod":[1,"next"]}}]],"provided_methods":[]},{"def_id":1,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["arith",0]},{"Impl":[{"Trait":1},171]}],"span":{"span":{"file_id":14,"beg":{"line":30,"col":8},"end":{"line":30,"col":36}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign"},"impl_trait":{"trait_id":5,"generics":{"regions":[],"types":[{"Ref":[{"Var":{"Free":0}},{"Literal":{"Integer":"I32"}},"Shared"]},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":5}}}},"generics":{"regions":[{"index":0,"name":"'a"}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[null,null],"consts":[],"types":[["Output",{"Literal":{"Integer":"I32"}}]],"type_clauses":[],"required_methods":[["mul",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":119,"generics":{"regions":[{"Var":{"Free":0}}],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":119}}}},"kind":{"TraitMethod":[5,"mul"]}}]],"provided_methods":[]},{"def_id":2,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["arith",0]},{"Impl":[{"Trait":2},137]}],"span":{"span":{"file_id":13,"beg":{"line":336,"col":8},"end":{"line":336,"col":23}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign"},"impl_trait":{"trait_id":5,"generics":{"regions":[],"types":[{"Literal":{"Integer":"I32"}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":5}}}},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[null,null],"consts":[],"types":[["Output",{"Literal":{"Integer":"I32"}}]],"type_clauses":[],"required_methods":[["mul",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":120,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":120}}}},"kind":{"TraitMethod":[5,"mul"]}}]],"provided_methods":[]}],"ordered_decls":[{"Type":{"NonRec":0}},{"Type":{"NonRec":1}},{"Fun":{"NonRec":2}},{"Fun":{"NonRec":119}},{"Fun":{"NonRec":3}},{"Type":{"NonRec":2}},{"TraitDecl":{"NonRec":3}},{"TraitDecl":{"NonRec":2}},{"TraitDecl":{"NonRec":1}},{"Fun":{"NonRec":121}},{"TraitImpl":{"NonRec":0}},{"Fun":{"NonRec":4}},{"Fun":{"NonRec":0}},{"Fun":{"NonRec":1}},{"Fun":{"NonRec":5}},{"TraitDecl":{"NonRec":5}},{"TraitImpl":{"NonRec":1}},{"Fun":{"NonRec":6}},{"Fun":{"NonRec":7}},{"Fun":{"NonRec":8}},{"TraitDecl":{"NonRec":6}},{"TraitDecl":{"NonRec":7}},{"TraitDecl":{"NonRec":8}},{"TraitDecl":{"NonRec":23}},{"Type":{"NonRec":4}},{"TraitDecl":{"NonRec":9}},{"TraitDecl":{"NonRec":10}},{"TraitDecl":{"NonRec":11}},{"TraitDecl":{"NonRec":12}},{"TraitDecl":{"NonRec":13}},{"TraitDecl":{"NonRec":14}},{"TraitDecl":{"NonRec":20}},{"TraitDecl":{"NonRec":22}},{"Type":{"NonRec":3}},{"TraitDecl":{"NonRec":19}},{"TraitDecl":{"NonRec":15}},{"TraitDecl":{"NonRec":16}},{"TraitDecl":{"NonRec":17}},{"TraitDecl":{"NonRec":18}},{"TraitDecl":{"NonRec":21}},{"Fun":{"NonRec":84}},{"Fun":{"NonRec":86}},{"Fun":{"NonRec":88}},{"Fun":{"NonRec":93}},{"Fun":{"NonRec":98}},{"Fun":{"NonRec":99}},{"Fun":{"NonRec":100}},{"Fun":{"NonRec":101}},{"Fun":{"NonRec":103}},{"Fun":{"NonRec":104}},{"Fun":{"NonRec":105}},{"Fun":{"NonRec":106}},{"Fun":{"NonRec":107}},{"Fun":{"NonRec":111}},{"Fun":{"NonRec":120}},{"TraitImpl":{"NonRec":2}}]}}