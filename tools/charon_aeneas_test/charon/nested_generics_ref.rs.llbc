{"charon_version":"0.1.67","translated":{"crate_name":"rem_cli","real_crate_name":"rem_cli","options":{"ullbc":false,"lib":false,"bin":null,"mir_promoted":false,"mir_optimized":false,"crate_name":null,"input_file":"/home/matt/rem-matt/rem-cli/tools/charon_aeneas_test/rust/nested_generics_ref.rs","read_llbc":null,"dest_dir":null,"dest_file":"/home/matt/rem-matt/rem-cli/tools/charon_aeneas_test/charon/nested_generics_ref.rs.llbc","use_polonius":false,"no_code_duplication":false,"extract_opaque_bodies":false,"translate_all_methods":false,"include":[],"opaque":[],"exclude":[],"remove_associated_types":[],"hide_marker_traits":true,"no_cargo":false,"rustc_args":[],"cargo_args":[],"abort_on_error":false,"error_on_warnings":false,"no_serialize":false,"print_original_ullbc":false,"print_ullbc":false,"print_built_llbc":false,"print_llbc":false,"no_merge_goto_chains":false},"all_ids":[{"Type":0},{"TraitDecl":0},{"TraitDecl":1},{"TraitDecl":2},{"Fun":0},{"Fun":1},{"Fun":2},{"Fun":3},{"TraitDecl":3},{"Fun":4},{"Fun":5}],"item_names":[{"key":{"Fun":0},"value":[{"Ident":["rem_cli",0]},{"Impl":[{"Ty":{"params":{"regions":[],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":0,"beg":{"line":2,"col":9},"end":{"line":2,"col":18}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},{"clause_id":2,"span":{"span":{"file_id":0,"beg":{"line":2,"col":21},"end":{"line":2,"col":25}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"trait_id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":[{"Adt":0},{"regions":[],"types":[{"TypeVar":{"Bound":[0,0]}}],"const_generics":[],"trait_refs":[null,{"kind":{"Clause":{"Bound":[0,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"target":{"Item":{"Type":0}}}]},"kind":"InherentImplBlock"}},0]},{"Ident":["func",0]}]},{"key":{"TraitDecl":0},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Sized",0]}]},{"key":{"Fun":1},"value":[{"Ident":["rem_cli",0]},{"Ident":["fun_name",0]}]},{"key":{"Fun":3},"value":[{"Ident":["core",0]},{"Ident":["convert",0]},{"Ident":["Into",0]},{"Ident":["into",0]}]},{"key":{"TraitDecl":2},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Copy",0]}]},{"key":{"Fun":5},"value":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["Clone",0]},{"Ident":["clone_from",0]}]},{"key":{"TraitDecl":1},"value":[{"Ident":["core",0]},{"Ident":["convert",0]},{"Ident":["Into",0]}]},{"key":{"TraitDecl":3},"value":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["Clone",0]}]},{"key":{"Type":0},"value":[{"Ident":["rem_cli",0]},{"Ident":["Struct",0]}]},{"key":{"Fun":4},"value":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["Clone",0]},{"Ident":["clone",0]}]},{"key":{"Fun":2},"value":[{"Ident":["rem_cli",0]},{"Ident":["main",0]}]}],"files":[{"name":{"Local":"/home/matt/rem-matt/rem-cli/tools/charon_aeneas_test/rust/nested_generics_ref.rs"},"contents":"struct Struct<T: Into<i32>>(T);\nimpl <T: Into<i32> + Copy> Struct<T> {\n    fn func<V: Into<i32>>(&self, v: V) -> i32 {\n        let t = self.0;\n        fun_name(t, v)\n    }\n}\n\nfn fun_name<T: Into<i32> + Copy, V: Into<i32>>(t: T, v: V) -> i32 {\n    t.into() + v.into()\n}\n\nfn main() {\n\n}\n"},{"name":{"Virtual":"/rustc/library/core/src/lib.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/marker.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/convert/mod.rs"},"contents":null},{"name":{"Virtual":"/rustc/library/core/src/clone.rs"},"contents":null}],"type_decls":[{"def_id":0,"item_meta":{"name":[{"Ident":["rem_cli",0]},{"Ident":["Struct",0]}],"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":31}},"generated_from_span":null},"source_text":"struct Struct<T: Into<i32>>(T);","attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":true,"opacity":"Transparent"},"generics":{"regions":[],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":0,"beg":{"line":1,"col":17},"end":{"line":1,"col":26}},"generated_from_span":null},"origin":"WhereClauseOnType","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"kind":{"Struct":[{"span":{"span":{"file_id":0,"beg":{"line":1,"col":28},"end":{"line":1,"col":29}},"generated_from_span":null},"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"name":null,"ty":{"TypeVar":{"Free":0}}}]}}],"fun_decls":[{"def_id":0,"item_meta":{"name":[{"Ident":["rem_cli",0]},{"Impl":[{"Ty":{"params":{"regions":[],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":0,"beg":{"line":2,"col":9},"end":{"line":2,"col":18}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},{"clause_id":2,"span":{"span":{"file_id":0,"beg":{"line":2,"col":21},"end":{"line":2,"col":25}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"trait_id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":[{"Adt":0},{"regions":[],"types":[{"TypeVar":{"Bound":[0,0]}}],"const_generics":[],"trait_refs":[null,{"kind":{"Clause":{"Bound":[0,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"target":{"Item":{"Type":0}}}]},"kind":"InherentImplBlock"}},0]},{"Ident":["func",0]}],"span":{"span":{"file_id":0,"beg":{"line":3,"col":4},"end":{"line":6,"col":5}},"generated_from_span":null},"source_text":"fn func<V: Into<i32>>(&self, v: V) -> i32 {\n        let t = self.0;\n        fun_name(t, v)\n    }","attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":true,"opacity":"Transparent"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"T"},{"index":1,"name":"V"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":0,"beg":{"line":2,"col":9},"end":{"line":2,"col":18}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},{"clause_id":2,"span":{"span":{"file_id":0,"beg":{"line":2,"col":21},"end":{"line":2,"col":25}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"trait_id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}}}},null,{"clause_id":4,"span":{"span":{"file_id":0,"beg":{"line":3,"col":15},"end":{"line":3,"col":24}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":1}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":[{"Adt":0},{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null,{"kind":{"Clause":{"Free":1}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"target":{"Item":{"Type":0}}}]},"Shared"]},{"TypeVar":{"Free":1}}],"output":{"Literal":{"Integer":"I32"}}},"kind":"Regular","is_global_initializer":null,"body":{"Ok":{"Structured":{"span":{"span":{"file_id":0,"beg":{"line":3,"col":4},"end":{"line":6,"col":5}},"generated_from_span":null},"locals":{"arg_count":2,"vars":[{"index":0,"name":null,"ty":{"Literal":{"Integer":"I32"}}},{"index":1,"name":"self","ty":{"Ref":["Erased",{"Adt":[{"Adt":0},{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null,{"kind":{"Clause":{"Free":1}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"target":{"Item":{"Type":0}}}]},"Shared"]}},{"index":2,"name":"v","ty":{"TypeVar":{"Free":1}}},{"index":3,"name":"t","ty":{"TypeVar":{"Free":0}}},{"index":4,"name":null,"ty":{"TypeVar":{"Free":0}}},{"index":5,"name":null,"ty":{"TypeVar":{"Free":1}}}]},"comments":[],"body":{"span":{"span":{"file_id":0,"beg":{"line":4,"col":12},"end":{"line":6,"col":5}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":4,"col":16},"end":{"line":4,"col":22}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":3},"ty":{"TypeVar":{"Free":0}}},{"Use":{"Copy":{"kind":{"Projection":[{"kind":{"Projection":[{"kind":{"Base":1},"ty":{"Ref":["Erased",{"Adt":[{"Adt":0},{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null,{"kind":{"Clause":{"Free":1}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"target":{"Item":{"Type":0}}}]},"Shared"]}},"Deref"]},"ty":{"Adt":[{"Adt":0},{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null,{"kind":{"Clause":{"Free":1}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"target":{"Item":{"Type":0}}}]}},{"Field":[{"Adt":[0,null]},0]}]},"ty":{"TypeVar":{"Free":0}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":12},"end":{"line":4,"col":13}},"generated_from_span":null},"content":{"FakeRead":{"kind":{"Base":3},"ty":{"TypeVar":{"Free":0}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":17},"end":{"line":5,"col":18}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":4},"ty":{"TypeVar":{"Free":0}}},{"Use":{"Copy":{"kind":{"Base":3},"ty":{"TypeVar":{"Free":0}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":20},"end":{"line":5,"col":21}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":5},"ty":{"TypeVar":{"Free":1}}},{"Use":{"Move":{"kind":{"Base":2},"ty":{"TypeVar":{"Free":1}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":8},"end":{"line":5,"col":22}},"generated_from_span":null},"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":1}},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[null,null,{"kind":{"Clause":{"Free":1}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},{"kind":{"Clause":{"Free":2}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}}}},{"kind":{"Clause":{"Free":4}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":1}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"target":{"Item":{"Fun":1}}}}},"args":[{"Move":{"kind":{"Base":4},"ty":{"TypeVar":{"Free":0}}}},{"Move":{"kind":{"Base":5},"ty":{"TypeVar":{"Free":1}}}}],"dest":{"kind":{"Base":0},"ty":{"Literal":{"Integer":"I32"}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":21},"end":{"line":5,"col":22}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":5},"ty":{"TypeVar":{"Free":1}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":21},"end":{"line":5,"col":22}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":4},"ty":{"TypeVar":{"Free":0}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":6,"col":4},"end":{"line":6,"col":5}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":3},"ty":{"TypeVar":{"Free":0}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":6,"col":4},"end":{"line":6,"col":5}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":2},"ty":{"TypeVar":{"Free":1}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":6,"col":5},"end":{"line":6,"col":5}},"generated_from_span":null},"content":"Return","comments_before":[]}]}}}}},{"def_id":1,"item_meta":{"name":[{"Ident":["rem_cli",0]},{"Ident":["fun_name",0]}],"span":{"span":{"file_id":0,"beg":{"line":9,"col":0},"end":{"line":11,"col":1}},"generated_from_span":null},"source_text":"fn fun_name<T: Into<i32> + Copy, V: Into<i32>>(t: T, v: V) -> i32 {\n    t.into() + v.into()\n}","attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":true,"opacity":"Transparent"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[{"index":0,"name":"T"},{"index":1,"name":"V"}],"const_generics":[],"trait_clauses":[null,null,{"clause_id":2,"span":{"span":{"file_id":0,"beg":{"line":9,"col":15},"end":{"line":9,"col":24}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},{"clause_id":3,"span":{"span":{"file_id":0,"beg":{"line":9,"col":27},"end":{"line":9,"col":31}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":2}}}}}},{"clause_id":4,"span":{"span":{"file_id":0,"beg":{"line":9,"col":36},"end":{"line":9,"col":45}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":1}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"output":{"Literal":{"Integer":"I32"}}},"kind":"Regular","is_global_initializer":null,"body":{"Ok":{"Structured":{"span":{"span":{"file_id":0,"beg":{"line":9,"col":0},"end":{"line":11,"col":1}},"generated_from_span":null},"locals":{"arg_count":2,"vars":[{"index":0,"name":null,"ty":{"Literal":{"Integer":"I32"}}},{"index":1,"name":"t","ty":{"TypeVar":{"Free":0}}},{"index":2,"name":"v","ty":{"TypeVar":{"Free":1}}},{"index":3,"name":null,"ty":{"Literal":{"Integer":"I32"}}},{"index":4,"name":null,"ty":{"TypeVar":{"Free":0}}},{"index":5,"name":null,"ty":{"Literal":{"Integer":"I32"}}},{"index":6,"name":null,"ty":{"TypeVar":{"Free":1}}}]},"comments":[],"body":{"span":{"span":{"file_id":0,"beg":{"line":10,"col":4},"end":{"line":11,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":10,"col":4},"end":{"line":10,"col":5}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":4},"ty":{"TypeVar":{"Free":0}}},{"Use":{"Copy":{"kind":{"Base":1},"ty":{"TypeVar":{"Free":0}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":10,"col":4},"end":{"line":10,"col":12}},"generated_from_span":null},"content":{"Call":{"func":{"Regular":{"func":{"Trait":[{"kind":{"Clause":{"Free":2}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},"into",3]},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Method":[1,"into"]}}}},"args":[{"Move":{"kind":{"Base":4},"ty":{"TypeVar":{"Free":0}}}}],"dest":{"kind":{"Base":3},"ty":{"Literal":{"Integer":"I32"}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":10,"col":11},"end":{"line":10,"col":12}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":4},"ty":{"TypeVar":{"Free":0}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":10,"col":15},"end":{"line":10,"col":16}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":6},"ty":{"TypeVar":{"Free":1}}},{"Use":{"Move":{"kind":{"Base":2},"ty":{"TypeVar":{"Free":1}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":10,"col":15},"end":{"line":10,"col":23}},"generated_from_span":null},"content":{"Call":{"func":{"Regular":{"func":{"Trait":[{"kind":{"Clause":{"Free":4}},"trait_decl_ref":{"regions":[],"skip_binder":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":1}},{"Literal":{"Integer":"I32"}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}}}},"into",3]},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":{"Method":[1,"into"]}}}},"args":[{"Move":{"kind":{"Base":6},"ty":{"TypeVar":{"Free":1}}}}],"dest":{"kind":{"Base":5},"ty":{"Literal":{"Integer":"I32"}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":10,"col":22},"end":{"line":10,"col":23}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":6},"ty":{"TypeVar":{"Free":1}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":10,"col":4},"end":{"line":10,"col":23}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":0},"ty":{"Literal":{"Integer":"I32"}}},{"BinaryOp":["Add",{"Move":{"kind":{"Base":3},"ty":{"Literal":{"Integer":"I32"}}}},{"Move":{"kind":{"Base":5},"ty":{"Literal":{"Integer":"I32"}}}}]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":10,"col":22},"end":{"line":10,"col":23}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":5},"ty":{"Literal":{"Integer":"I32"}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":10,"col":22},"end":{"line":10,"col":23}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":3},"ty":{"Literal":{"Integer":"I32"}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":11,"col":0},"end":{"line":11,"col":1}},"generated_from_span":null},"content":{"Drop":{"kind":{"Base":2},"ty":{"TypeVar":{"Free":1}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":11,"col":1},"end":{"line":11,"col":1}},"generated_from_span":null},"content":"Return","comments_before":[]}]}}}}},{"def_id":2,"item_meta":{"name":[{"Ident":["rem_cli",0]},{"Ident":["main",0]}],"span":{"span":{"file_id":0,"beg":{"line":13,"col":0},"end":{"line":15,"col":1}},"generated_from_span":null},"source_text":"fn main() {\n\n}","attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":true,"opacity":"Transparent"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[],"output":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},"kind":"Regular","is_global_initializer":null,"body":{"Ok":{"Structured":{"span":{"span":{"file_id":0,"beg":{"line":13,"col":0},"end":{"line":15,"col":1}},"generated_from_span":null},"locals":{"arg_count":0,"vars":[{"index":0,"name":null,"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"index":1,"name":null,"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}}]},"comments":[],"body":{"span":{"span":{"file_id":0,"beg":{"line":13,"col":10},"end":{"line":15,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":13,"col":10},"end":{"line":15,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":1},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"Aggregate":[{"Adt":["Tuple",null,null,{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},[]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":13,"col":10},"end":{"line":15,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":0},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"Use":{"Move":{"kind":{"Base":1},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":15,"col":1},"end":{"line":15,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Base":0},"ty":{"Adt":["Tuple",{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]}},{"Aggregate":[{"Adt":["Tuple",null,null,{"regions":[],"types":[],"const_generics":[],"trait_refs":[],"target":"Builtin"}]},[]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":15,"col":1},"end":{"line":15,"col":1}},"generated_from_span":null},"content":"Return","comments_before":[]}]}}}}},{"def_id":3,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["convert",0]},{"Ident":["Into",0]},{"Ident":["into",0]}],"span":{"span":{"file_id":3,"beg":{"line":450,"col":4},"end":{"line":450,"col":23}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Converts this type into the (usually inferred) input type."},{"Unknown":{"path":"must_use","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"T"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":0}}],"output":{"TypeVar":{"Free":1}}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":1}}}},"item_name":"into","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":4,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["Clone",0]},{"Ident":["clone",0]}],"span":{"span":{"file_id":4,"beg":{"line":165,"col":4},"end":{"line":165,"col":28}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Returns a copy of the value."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #![allow(noop_method_call)]"},{"DocComment":" let hello = \"Hello\"; // &str implements Clone"},{"DocComment":""},{"DocComment":" assert_eq!(\"Hello\", hello.clone());"},{"DocComment":" ```"},{"Unknown":{"path":"must_use","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"signature":{"is_unsafe":false,"is_closure":false,"closure_info":null,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]}],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"trait_id":3,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":3}}}},"item_name":"clone","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null],"global_decls":[],"trait_decls":[null,{"def_id":1,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["convert",0]},{"Ident":["Into",0]}],"span":{"span":{"file_id":3,"beg":{"line":446,"col":0},"end":{"line":446,"col":24}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" A value-to-value conversion that consumes the input value. The"},{"DocComment":" opposite of [`From`]."},{"DocComment":""},{"DocComment":" One should avoid implementing [`Into`] and implement [`From`] instead."},{"DocComment":" Implementing [`From`] automatically provides one with an implementation of [`Into`]"},{"DocComment":" thanks to the blanket implementation in the standard library."},{"DocComment":""},{"DocComment":" Prefer using [`Into`] over [`From`] when specifying trait bounds on a generic function"},{"DocComment":" to ensure that types that only implement [`Into`] can be used as well."},{"DocComment":""},{"DocComment":" **Note: This trait must not fail**. If the conversion can fail, use [`TryInto`]."},{"DocComment":""},{"DocComment":" # Generic Implementations"},{"DocComment":""},{"DocComment":" - [`From`]`<T> for U` implies `Into<U> for T`"},{"DocComment":" - [`Into`] is reflexive, which means that `Into<T> for T` is implemented"},{"DocComment":""},{"DocComment":" # Implementing [`Into`] for conversions to external types in old versions of Rust"},{"DocComment":""},{"DocComment":" Prior to Rust 1.41, if the destination type was not part of the current crate"},{"DocComment":" then you couldn't implement [`From`] directly."},{"DocComment":" For example, take this code:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #![allow(non_local_definitions)]"},{"DocComment":" struct Wrapper<T>(Vec<T>);"},{"DocComment":" impl<T> From<Wrapper<T>> for Vec<T> {"},{"DocComment":"     fn from(w: Wrapper<T>) -> Vec<T> {"},{"DocComment":"         w.0"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":" This will fail to compile in older versions of the language because Rust's orphaning rules"},{"DocComment":" used to be a little bit more strict. To bypass this, you could implement [`Into`] directly:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" struct Wrapper<T>(Vec<T>);"},{"DocComment":" impl<T> Into<Vec<T>> for Wrapper<T> {"},{"DocComment":"     fn into(self) -> Vec<T> {"},{"DocComment":"         self.0"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" It is important to understand that [`Into`] does not provide a [`From`] implementation"},{"DocComment":" (as [`From`] does with [`Into`]). Therefore, you should always try to implement [`From`]"},{"DocComment":" and then fall back to [`Into`] if [`From`] can't be implemented."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" [`String`] implements [`Into`]`<`[`Vec`]`<`[`u8`]`>>`:"},{"DocComment":""},{"DocComment":" In order to express that we want a generic function to take all arguments that can be"},{"DocComment":" converted to a specified type `T`, we can use a trait bound of [`Into`]`<T>`."},{"DocComment":" For example: The function `is_hello` takes all arguments that can be converted into a"},{"DocComment":" [`Vec`]`<`[`u8`]`>`."},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" fn is_hello<T: Into<Vec<u8>>>(s: T) {"},{"DocComment":"    let bytes = b\"hello\".to_vec();"},{"DocComment":"    assert_eq!(bytes, s.into());"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let s = \"hello\".to_string();"},{"DocComment":" is_hello(s);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`String`]: ../../std/string/struct.String.html"},{"DocComment":" [`Vec`]: ../../std/vec/struct.Vec.html"},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"T"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[["into",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":3,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":3}}}},"kind":{"TraitMethod":[1,"into"]}}]],"provided_methods":[]},{"def_id":2,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Copy",0]}],"span":{"span":{"file_id":2,"beg":{"line":416,"col":0},"end":{"line":416,"col":21}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Types whose values can be duplicated simply by copying bits."},{"DocComment":""},{"DocComment":" By default, variable bindings have 'move semantics.' In other"},{"DocComment":" words:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(Debug)]"},{"DocComment":" struct Foo;"},{"DocComment":""},{"DocComment":" let x = Foo;"},{"DocComment":""},{"DocComment":" let y = x;"},{"DocComment":""},{"DocComment":" // `x` has moved into `y`, and so cannot be used"},{"DocComment":""},{"DocComment":" // println!(\"{x:?}\"); // error: use of moved value"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" However, if a type implements `Copy`, it instead has 'copy semantics':"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // We can derive a `Copy` implementation. `Clone` is also required, as it's"},{"DocComment":" // a supertrait of `Copy`."},{"DocComment":" #[derive(Debug, Copy, Clone)]"},{"DocComment":" struct Foo;"},{"DocComment":""},{"DocComment":" let x = Foo;"},{"DocComment":""},{"DocComment":" let y = x;"},{"DocComment":""},{"DocComment":" // `y` is a copy of `x`"},{"DocComment":""},{"DocComment":" println!(\"{x:?}\"); // A-OK!"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" It's important to note that in these two examples, the only difference is whether you"},{"DocComment":" are allowed to access `x` after the assignment. Under the hood, both a copy and a move"},{"DocComment":" can result in bits being copied in memory, although this is sometimes optimized away."},{"DocComment":""},{"DocComment":" ## How can I implement `Copy`?"},{"DocComment":""},{"DocComment":" There are two ways to implement `Copy` on your type. The simplest is to use `derive`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(Copy, Clone)]"},{"DocComment":" struct MyStruct;"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" You can also implement `Copy` and `Clone` manually:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" struct MyStruct;"},{"DocComment":""},{"DocComment":" impl Copy for MyStruct { }"},{"DocComment":""},{"DocComment":" impl Clone for MyStruct {"},{"DocComment":"     fn clone(&self) -> MyStruct {"},{"DocComment":"         *self"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" There is a small difference between the two. The `derive` strategy will also place a `Copy`"},{"DocComment":" bound on type parameters:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(Clone)]"},{"DocComment":" struct MyStruct<T>(T);"},{"DocComment":""},{"DocComment":" impl<T: Copy> Copy for MyStruct<T> { }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" This isn't always desired. For example, shared references (`&T`) can be copied regardless of"},{"DocComment":" whether `T` is `Copy`. Likewise, a generic struct containing markers such as [`PhantomData`]"},{"DocComment":" could potentially be duplicated with a bit-wise copy."},{"DocComment":""},{"DocComment":" ## What's the difference between `Copy` and `Clone`?"},{"DocComment":""},{"DocComment":" Copies happen implicitly, for example as part of an assignment `y = x`. The behavior of"},{"DocComment":" `Copy` is not overloadable; it is always a simple bit-wise copy."},{"DocComment":""},{"DocComment":" Cloning is an explicit action, `x.clone()`. The implementation of [`Clone`] can"},{"DocComment":" provide any type-specific behavior necessary to duplicate values safely. For example,"},{"DocComment":" the implementation of [`Clone`] for [`String`] needs to copy the pointed-to string"},{"DocComment":" buffer in the heap. A simple bitwise copy of [`String`] values would merely copy the"},{"DocComment":" pointer, leading to a double free down the line. For this reason, [`String`] is [`Clone`]"},{"DocComment":" but not `Copy`."},{"DocComment":""},{"DocComment":" [`Clone`] is a supertrait of `Copy`, so everything which is `Copy` must also implement"},{"DocComment":" [`Clone`]. If a type is `Copy` then its [`Clone`] implementation only needs to return `*self`"},{"DocComment":" (see the example above)."},{"DocComment":""},{"DocComment":" ## When can my type be `Copy`?"},{"DocComment":""},{"DocComment":" A type can implement `Copy` if all of its components implement `Copy`. For example, this"},{"DocComment":" struct can be `Copy`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #[allow(dead_code)]"},{"DocComment":" #[derive(Copy, Clone)]"},{"DocComment":" struct Point {"},{"DocComment":"    x: i32,"},{"DocComment":"    y: i32,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" A struct can be `Copy`, and [`i32`] is `Copy`, therefore `Point` is eligible to be `Copy`."},{"DocComment":" By contrast, consider"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #![allow(dead_code)]"},{"DocComment":" # struct Point;"},{"DocComment":" struct PointList {"},{"DocComment":"     points: Vec<Point>,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" The struct `PointList` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`. If we"},{"DocComment":" attempt to derive a `Copy` implementation, we'll get an error:"},{"DocComment":""},{"DocComment":" ```text"},{"DocComment":" the trait `Copy` cannot be implemented for this type; field `points` does not implement `Copy`"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Shared references (`&T`) are also `Copy`, so a type can be `Copy`, even when it holds"},{"DocComment":" shared references of types `T` that are *not* `Copy`. Consider the following struct,"},{"DocComment":" which can implement `Copy`, because it only holds a *shared reference* to our non-`Copy`"},{"DocComment":" type `PointList` from above:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #![allow(dead_code)]"},{"DocComment":" # struct PointList;"},{"DocComment":" #[derive(Copy, Clone)]"},{"DocComment":" struct PointListWrapper<'a> {"},{"DocComment":"     point_list_ref: &'a PointList,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## When *can't* my type be `Copy`?"},{"DocComment":""},{"DocComment":" Some types can't be copied safely. For example, copying `&mut T` would create an aliased"},{"DocComment":" mutable reference. Copying [`String`] would duplicate responsibility for managing the"},{"DocComment":" [`String`]'s buffer, leading to a double free."},{"DocComment":""},{"DocComment":" Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's"},{"DocComment":" managing some resource besides its own [`size_of::<T>`] bytes."},{"DocComment":""},{"DocComment":" If you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get"},{"DocComment":" the error [E0204]."},{"DocComment":""},{"DocComment":" [E0204]: ../../error_codes/E0204.html"},{"DocComment":""},{"DocComment":" ## When *should* my type be `Copy`?"},{"DocComment":""},{"DocComment":" Generally speaking, if your type _can_ implement `Copy`, it should. Keep in mind, though,"},{"DocComment":" that implementing `Copy` is part of the public API of your type. If the type might become"},{"DocComment":" non-`Copy` in the future, it could be prudent to omit the `Copy` implementation now, to"},{"DocComment":" avoid a breaking API change."},{"DocComment":""},{"DocComment":" ## Additional implementors"},{"DocComment":""},{"DocComment":" In addition to the [implementors listed below][impls],"},{"DocComment":" the following types also implement `Copy`:"},{"DocComment":""},{"DocComment":" * Function item types (i.e., the distinct types defined for each function)"},{"DocComment":" * Function pointer types (e.g., `fn() -> i32`)"},{"DocComment":" * Closure types, if they capture no value from the environment"},{"DocComment":"   or if all such captured values implement `Copy` themselves."},{"DocComment":"   Note that variables captured by shared reference always implement `Copy`"},{"DocComment":"   (even if the referent doesn't),"},{"DocComment":"   while variables captured by mutable reference never implement `Copy`."},{"DocComment":""},{"DocComment":" [`Vec<T>`]: ../../std/vec/struct.Vec.html"},{"DocComment":" [`String`]: ../../std/string/struct.String.html"},{"DocComment":" [`size_of::<T>`]: crate::mem::size_of"},{"DocComment":" [impls]: #implementors"},{"Unknown":{"path":"rustc_diagnostic_item","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[{"clause_id":0,"span":{"span":{"file_id":2,"beg":{"line":416,"col":16},"end":{"line":416,"col":21}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"trait_id":3,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"TraitDecl":3}}}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[],"provided_methods":[]},{"def_id":3,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["Clone",0]}],"span":{"span":{"file_id":4,"beg":{"line":149,"col":0},"end":{"line":149,"col":22}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" A common trait for the ability to explicitly duplicate an object."},{"DocComment":""},{"DocComment":" Differs from [`Copy`] in that [`Copy`] is implicit and an inexpensive bit-wise copy, while"},{"DocComment":" `Clone` is always explicit and may or may not be expensive. In order to enforce"},{"DocComment":" these characteristics, Rust does not allow you to reimplement [`Copy`], but you"},{"DocComment":" may reimplement `Clone` and run arbitrary code."},{"DocComment":""},{"DocComment":" Since `Clone` is more general than [`Copy`], you can automatically make anything"},{"DocComment":" [`Copy`] be `Clone` as well."},{"DocComment":""},{"DocComment":" ## Derivable"},{"DocComment":""},{"DocComment":" This trait can be used with `#[derive]` if all fields are `Clone`. The `derive`d"},{"DocComment":" implementation of [`Clone`] calls [`clone`] on each field."},{"DocComment":""},{"DocComment":" [`clone`]: Clone::clone"},{"DocComment":""},{"DocComment":" For a generic struct, `#[derive]` implements `Clone` conditionally by adding bound `Clone` on"},{"DocComment":" generic parameters."},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // `derive` implements Clone for Reading<T> when T is Clone."},{"DocComment":" #[derive(Clone)]"},{"DocComment":" struct Reading<T> {"},{"DocComment":"     frequency: T,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## How can I implement `Clone`?"},{"DocComment":""},{"DocComment":" Types that are [`Copy`] should have a trivial implementation of `Clone`. More formally:"},{"DocComment":" if `T: Copy`, `x: T`, and `y: &T`, then `let x = y.clone();` is equivalent to `let x = *y;`."},{"DocComment":" Manual implementations should be careful to uphold this invariant; however, unsafe code"},{"DocComment":" must not rely on it to ensure memory safety."},{"DocComment":""},{"DocComment":" An example is a generic struct holding a function pointer. In this case, the"},{"DocComment":" implementation of `Clone` cannot be `derive`d, but can be implemented as:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" struct Generate<T>(fn() -> T);"},{"DocComment":""},{"DocComment":" impl<T> Copy for Generate<T> {}"},{"DocComment":""},{"DocComment":" impl<T> Clone for Generate<T> {"},{"DocComment":"     fn clone(&self) -> Self {"},{"DocComment":"         *self"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" If we `derive`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(Copy, Clone)]"},{"DocComment":" struct Generate<T>(fn() -> T);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" the auto-derived implementations will have unnecessary `T: Copy` and `T: Clone` bounds:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # struct Generate<T>(fn() -> T);"},{"DocComment":""},{"DocComment":" // Automatically derived"},{"DocComment":" impl<T: Copy> Copy for Generate<T> { }"},{"DocComment":""},{"DocComment":" // Automatically derived"},{"DocComment":" impl<T: Clone> Clone for Generate<T> {"},{"DocComment":"     fn clone(&self) -> Generate<T> {"},{"DocComment":"         Generate(Clone::clone(&self.0))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" The bounds are unnecessary because clearly the function itself should be"},{"DocComment":" copy- and cloneable even if its return type is not:"},{"DocComment":""},{"DocComment":" ```compile_fail,E0599"},{"DocComment":" #[derive(Copy, Clone)]"},{"DocComment":" struct Generate<T>(fn() -> T);"},{"DocComment":""},{"DocComment":" struct NotCloneable;"},{"DocComment":""},{"DocComment":" fn generate_not_cloneable() -> NotCloneable {"},{"DocComment":"     NotCloneable"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" Generate(generate_not_cloneable).clone(); // error: trait bounds were not satisfied"},{"DocComment":" // Note: With the manual implementations the above line will compile."},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## Additional implementors"},{"DocComment":""},{"DocComment":" In addition to the [implementors listed below][impls],"},{"DocComment":" the following types also implement `Clone`:"},{"DocComment":""},{"DocComment":" * Function item types (i.e., the distinct types defined for each function)"},{"DocComment":" * Function pointer types (e.g., `fn() -> i32`)"},{"DocComment":" * Closure types, if they capture no value from the environment"},{"DocComment":"   or if all such captured values implement `Clone` themselves."},{"DocComment":"   Note that variables captured by shared reference always implement `Clone`"},{"DocComment":"   (even if the referent doesn't),"},{"DocComment":"   while variables captured by mutable reference never implement `Clone`."},{"DocComment":""},{"DocComment":" [impls]: #implementors"},{"Unknown":{"path":"rustc_diagnostic_item","args":null}},{"Unknown":{"path":"rustc_trivial_field_reads","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"required_methods":[["clone",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":4,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[],"target":{"Item":{"Fun":4}}}},"kind":{"TraitMethod":[3,"clone"]}}]],"provided_methods":[]}],"trait_impls":[],"ordered_decls":[{"TraitDecl":{"NonRec":1}},{"Type":{"NonRec":0}},{"TraitDecl":{"NonRec":3}},{"TraitDecl":{"NonRec":2}},{"Fun":{"NonRec":3}},{"Fun":{"NonRec":1}},{"Fun":{"NonRec":0}},{"Fun":{"NonRec":2}},{"Fun":{"NonRec":4}}]}}